#ifndef FLATBUFFERS_COMMON_READER_H
#define FLATBUFFERS_COMMON_READER_H

/* Generated by flatcc 0.6.1-dev FlatBuffers schema compiler for C by dvide.com */

/* Common FlatBuffers read functionality for C. */

#include "flatcc/flatcc_prologue.h"
#include "flatcc/flatcc_flatbuffers.h"


#define __flatbuffers_read_scalar_at_byteoffset(N, p, o) N ## _read_from_pe((uint8_t *)(p) + (o))
#define __flatbuffers_read_scalar(N, p) N ## _read_from_pe(p)
#define __flatbuffers_read_vt(ID, offset, t)\
flatbuffers_voffset_t offset = 0;\
{   flatbuffers_voffset_t id__tmp, *vt__tmp;\
    FLATCC_ASSERT(t != 0 && "null pointer table access");\
    id__tmp = ID;\
    vt__tmp = (flatbuffers_voffset_t *)((uint8_t *)(t) -\
        __flatbuffers_soffset_read_from_pe(t));\
    if (__flatbuffers_voffset_read_from_pe(vt__tmp) >= sizeof(vt__tmp[0]) * (id__tmp + 3u)) {\
        offset = __flatbuffers_voffset_read_from_pe(vt__tmp + id__tmp + 2);\
    }\
}
#define __flatbuffers_field_present(ID, t) { __flatbuffers_read_vt(ID, offset__tmp, t) return offset__tmp != 0; }
#define __flatbuffers_scalar_field(T, ID, t)\
{\
    __flatbuffers_read_vt(ID, offset__tmp, t)\
    if (offset__tmp) {\
        return (const T *)((uint8_t *)(t) + offset__tmp);\
    }\
    return 0;\
}
#define __flatbuffers_define_scalar_field(ID, N, NK, TK, T, V)\
static inline T N ## _ ## NK ## _get(N ## _table_t t__tmp)\
{ __flatbuffers_read_vt(ID, offset__tmp, t__tmp)\
  return offset__tmp ? __flatbuffers_read_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\
}\
static inline T N ## _ ## NK(N ## _table_t t__tmp)\
{ __flatbuffers_read_vt(ID, offset__tmp, t__tmp)\
  return offset__tmp ? __flatbuffers_read_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\
}\
static inline const T *N ## _ ## NK ## _get_ptr(N ## _table_t t__tmp)\
__flatbuffers_scalar_field(T, ID, t__tmp)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__flatbuffers_field_present(ID, t__tmp)\
__flatbuffers_define_scan_by_scalar_field(N, NK, T)
#define __flatbuffers_define_scalar_optional_field(ID, N, NK, TK, T, V)\
__flatbuffers_define_scalar_field(ID, N, NK, TK, T, V)\
static inline TK ## _option_t N ## _ ## NK ## _option(N ## _table_t t__tmp)\
{ TK ## _option_t ret; __flatbuffers_read_vt(ID, offset__tmp, t__tmp)\
  ret.is_null = offset__tmp == 0; ret.value = offset__tmp ?\
  __flatbuffers_read_scalar_at_byteoffset(TK, t__tmp, offset__tmp) : V;\
  return ret; }
#define __flatbuffers_struct_field(T, ID, t, r)\
{\
    __flatbuffers_read_vt(ID, offset__tmp, t)\
    if (offset__tmp) {\
        return (T)((uint8_t *)(t) + offset__tmp);\
    }\
    FLATCC_ASSERT(!(r) && "required field missing");\
    return 0;\
}
#define __flatbuffers_offset_field(T, ID, t, r, adjust)\
{\
    flatbuffers_uoffset_t *elem__tmp;\
    __flatbuffers_read_vt(ID, offset__tmp, t)\
    if (offset__tmp) {\
        elem__tmp = (flatbuffers_uoffset_t *)((uint8_t *)(t) + offset__tmp);\
        /* Add sizeof so C api can have raw access past header field. */\
        return (T)((uint8_t *)(elem__tmp) + adjust +\
              __flatbuffers_uoffset_read_from_pe(elem__tmp));\
    }\
    FLATCC_ASSERT(!(r) && "required field missing");\
    return 0;\
}
#define __flatbuffers_vector_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, sizeof(flatbuffers_uoffset_t))
#define __flatbuffers_table_field(T, ID, t, r) __flatbuffers_offset_field(T, ID, t, r, 0)
#define __flatbuffers_define_struct_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK ## _get(N ## _table_t t__tmp)\
__flatbuffers_struct_field(T, ID, t__tmp, r)\
static inline T N ## _ ## NK(N ## _table_t t__tmp)\
__flatbuffers_struct_field(T, ID, t__tmp, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__flatbuffers_field_present(ID, t__tmp)
#define __flatbuffers_define_vector_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK ## _get(N ## _table_t t__tmp)\
__flatbuffers_vector_field(T, ID, t__tmp, r)\
static inline T N ## _ ## NK(N ## _table_t t__tmp)\
__flatbuffers_vector_field(T, ID, t__tmp, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__flatbuffers_field_present(ID, t__tmp)
#define __flatbuffers_define_table_field(ID, N, NK, T, r)\
static inline T N ## _ ## NK ## _get(N ## _table_t t__tmp)\
__flatbuffers_table_field(T, ID, t__tmp, r)\
static inline T N ## _ ## NK(N ## _table_t t__tmp)\
__flatbuffers_table_field(T, ID, t__tmp, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__flatbuffers_field_present(ID, t__tmp)
#define __flatbuffers_define_string_field(ID, N, NK, r)\
static inline flatbuffers_string_t N ## _ ## NK ## _get(N ## _table_t t__tmp)\
__flatbuffers_vector_field(flatbuffers_string_t, ID, t__tmp, r)\
static inline flatbuffers_string_t N ## _ ## NK(N ## _table_t t__tmp)\
__flatbuffers_vector_field(flatbuffers_string_t, ID, t__tmp, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__flatbuffers_field_present(ID, t__tmp)\
__flatbuffers_define_scan_by_string_field(N, NK)
#define __flatbuffers_vec_len(vec)\
{ return (vec) ? (size_t)__flatbuffers_uoffset_read_from_pe((flatbuffers_uoffset_t *)vec - 1) : 0; }
#define __flatbuffers_string_len(s) __flatbuffers_vec_len(s)
static inline size_t flatbuffers_vec_len(const void *vec)
__flatbuffers_vec_len(vec)
#define __flatbuffers_scalar_vec_at(N, vec, i)\
{ FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && "index out of range");\
  return __flatbuffers_read_scalar(N, &(vec)[i]); }
#define __flatbuffers_struct_vec_at(vec, i)\
{ FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && "index out of range"); return (vec) + (i); }
/* `adjust` skips past the header for string vectors. */
#define __flatbuffers_offset_vec_at(T, vec, i, adjust)\
{ const flatbuffers_uoffset_t *elem__tmp = (vec) + (i);\
  FLATCC_ASSERT(flatbuffers_vec_len(vec) > (i) && "index out of range");\
  return (T)((uint8_t *)(elem__tmp) + (size_t)__flatbuffers_uoffset_read_from_pe(elem__tmp) + (adjust)); }
#define __flatbuffers_define_scalar_vec_len(N)\
static inline size_t N ## _vec_len(N ##_vec_t vec__tmp)\
{ return flatbuffers_vec_len(vec__tmp); }
#define __flatbuffers_define_scalar_vec_at(N, T) \
static inline T N ## _vec_at(N ## _vec_t vec__tmp, size_t i__tmp)\
__flatbuffers_scalar_vec_at(N, vec__tmp, i__tmp)
typedef const char *flatbuffers_string_t;
static inline size_t flatbuffers_string_len(flatbuffers_string_t s)
__flatbuffers_string_len(s)
typedef const flatbuffers_uoffset_t *flatbuffers_string_vec_t;
typedef flatbuffers_uoffset_t *flatbuffers_string_mutable_vec_t;
static inline size_t flatbuffers_string_vec_len(flatbuffers_string_vec_t vec)
__flatbuffers_vec_len(vec)
static inline flatbuffers_string_t flatbuffers_string_vec_at(flatbuffers_string_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(flatbuffers_string_t, vec, i, sizeof(vec[0]))
typedef const void *flatbuffers_generic_t;
typedef void *flatbuffers_mutable_generic_t;
static inline flatbuffers_string_t flatbuffers_string_cast_from_generic(const flatbuffers_generic_t p)
{ return p ? ((const char *)p) + __flatbuffers_uoffset__size() : 0; }
typedef const flatbuffers_uoffset_t *flatbuffers_generic_vec_t;
typedef flatbuffers_uoffset_t *flatbuffers_generic_table_mutable_vec_t;
static inline size_t flatbuffers_generic_vec_len(flatbuffers_generic_vec_t vec)
__flatbuffers_vec_len(vec)
static inline flatbuffers_generic_t flatbuffers_generic_vec_at(flatbuffers_generic_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(flatbuffers_generic_t, vec, i, 0)
static inline flatbuffers_generic_t flatbuffers_generic_vec_at_as_string(flatbuffers_generic_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(flatbuffers_generic_t, vec, i, sizeof(vec[0]))
typedef struct flatbuffers_union {
    flatbuffers_union_type_t type;
    flatbuffers_generic_t value;
} flatbuffers_union_t;
typedef struct flatbuffers_union_vec {
    const flatbuffers_union_type_t *type;
    const flatbuffers_uoffset_t *value;
} flatbuffers_union_vec_t;
typedef struct flatbuffers_mutable_union {
    flatbuffers_union_type_t type;
    flatbuffers_mutable_generic_t value;
} flatbuffers_mutable_union_t;
typedef struct flatbuffers_mutable_union_vec {
    flatbuffers_union_type_t *type;
    flatbuffers_uoffset_t *value;
} flatbuffers_mutable_union_vec_t;
static inline flatbuffers_mutable_union_t flatbuffers_mutable_union_cast(flatbuffers_union_t u__tmp)\
{ flatbuffers_mutable_union_t mu = { u__tmp.type, (flatbuffers_mutable_generic_t)u__tmp.value };\
  return mu; }
static inline flatbuffers_mutable_union_vec_t flatbuffers_mutable_union_vec_cast(flatbuffers_union_vec_t uv__tmp)\
{ flatbuffers_mutable_union_vec_t muv =\
  { (flatbuffers_union_type_t *)uv__tmp.type, (flatbuffers_uoffset_t *)uv__tmp.value }; return muv; }
#define __flatbuffers_union_type_field(ID, t)\
{\
    __flatbuffers_read_vt(ID, offset__tmp, t)\
    return offset__tmp ? __flatbuffers_read_scalar_at_byteoffset(__flatbuffers_utype, t, offset__tmp) : 0;\
}
static inline flatbuffers_string_t flatbuffers_string_cast_from_union(const flatbuffers_union_t u__tmp)\
{ return flatbuffers_string_cast_from_generic(u__tmp.value); }
#define __flatbuffers_define_union_field(NS, ID, N, NK, T, r)\
static inline T ## _union_type_t N ## _ ## NK ## _type_get(N ## _table_t t__tmp)\
__## NS ## union_type_field(((ID) - 1), t__tmp)\
static inline NS ## generic_t N ## _ ## NK ## _get(N ## _table_t t__tmp)\
__## NS ## table_field(NS ## generic_t, ID, t__tmp, r)\
static inline T ## _union_type_t N ## _ ## NK ## _type(N ## _table_t t__tmp)\
__## NS ## union_type_field(((ID) - 1), t__tmp)\
static inline NS ## generic_t N ## _ ## NK(N ## _table_t t__tmp)\
__## NS ## table_field(NS ## generic_t, ID, t__tmp, r)\
static inline int N ## _ ## NK ## _is_present(N ## _table_t t__tmp)\
__## NS ## field_present(ID, t__tmp)\
static inline T ## _union_t N ## _ ## NK ## _union(N ## _table_t t__tmp)\
{ T ## _union_t u__tmp = { 0, 0 }; u__tmp.type = N ## _ ## NK ## _type_get(t__tmp);\
  if (u__tmp.type == 0) return u__tmp; u__tmp.value = N ## _ ## NK ## _get(t__tmp); return u__tmp; }\
static inline NS ## string_t N ## _ ## NK ## _as_string(N ## _table_t t__tmp)\
{ return NS ## string_cast_from_generic(N ## _ ## NK ## _get(t__tmp)); }\

#define __flatbuffers_define_union_vector_ops(NS, T)\
static inline size_t T ## _union_vec_len(T ## _union_vec_t uv__tmp)\
{ return NS ## vec_len(uv__tmp.type); }\
static inline T ## _union_t T ## _union_vec_at(T ## _union_vec_t uv__tmp, size_t i__tmp)\
{ T ## _union_t u__tmp = { 0, 0 }; size_t n__tmp = NS ## vec_len(uv__tmp.type);\
  FLATCC_ASSERT(n__tmp > (i__tmp) && "index out of range"); u__tmp.type = uv__tmp.type[i__tmp];\
  /* Unknown type is treated as NONE for schema evolution. */\
  if (u__tmp.type == 0) return u__tmp;\
  u__tmp.value = NS ## generic_vec_at(uv__tmp.value, i__tmp); return u__tmp; }\
static inline NS ## string_t T ## _union_vec_at_as_string(T ## _union_vec_t uv__tmp, size_t i__tmp)\
{ return (NS ## string_t) NS ## generic_vec_at_as_string(uv__tmp.value, i__tmp); }\

#define __flatbuffers_define_union_vector(NS, T)\
typedef NS ## union_vec_t T ## _union_vec_t;\
typedef NS ## mutable_union_vec_t T ## _mutable_union_vec_t;\
static inline T ## _mutable_union_vec_t T ## _mutable_union_vec_cast(T ## _union_vec_t u__tmp)\
{ return NS ## mutable_union_vec_cast(u__tmp); }\
__## NS ## define_union_vector_ops(NS, T)
#define __flatbuffers_define_union(NS, T)\
typedef NS ## union_t T ## _union_t;\
typedef NS ## mutable_union_t T ## _mutable_union_t;\
static inline T ## _mutable_union_t T ## _mutable_union_cast(T ## _union_t u__tmp)\
{ return NS ## mutable_union_cast(u__tmp); }\
__## NS ## define_union_vector(NS, T)
#define __flatbuffers_define_union_vector_field(NS, ID, N, NK, T, r)\
__## NS ## define_vector_field(ID - 1, N, NK ## _type, T ## _vec_t, r)\
__## NS ## define_vector_field(ID, N, NK, flatbuffers_generic_vec_t, r)\
static inline T ## _union_vec_t N ## _ ## NK ## _union(N ## _table_t t__tmp)\
{ T ## _union_vec_t uv__tmp; uv__tmp.type = N ## _ ## NK ## _type_get(t__tmp);\
  uv__tmp.value = N ## _ ## NK(t__tmp);\
  FLATCC_ASSERT(NS ## vec_len(uv__tmp.type) == NS ## vec_len(uv__tmp.value)\
  && "union vector type length mismatch"); return uv__tmp; }
#include <string.h>
static const size_t flatbuffers_not_found = (size_t)-1;
static const size_t flatbuffers_end = (size_t)-1;
#define __flatbuffers_identity(n) (n)
#define __flatbuffers_min(a, b) ((a) < (b) ? (a) : (b))
/* Subtraction doesn't work for unsigned types. */
#define __flatbuffers_scalar_cmp(x, y, n) ((x) < (y) ? -1 : (x) > (y))
static inline int __flatbuffers_string_n_cmp(flatbuffers_string_t v, const char *s, size_t n)
{ size_t nv = flatbuffers_string_len(v); int x = strncmp(v, s, nv < n ? nv : n);
  return x != 0 ? x : nv < n ? -1 : nv > n; }
/* `n` arg unused, but needed by string find macro expansion. */
static inline int __flatbuffers_string_cmp(flatbuffers_string_t v, const char *s, size_t n) { (void)n; return strcmp(v, s); }
/* A = identity if searching scalar vectors rather than key fields. */
/* Returns lowest matching index or not_found. */
#define __flatbuffers_find_by_field(A, V, E, L, K, Kn, T, D)\
{ T v__tmp; size_t a__tmp = 0, b__tmp, m__tmp; if (!(b__tmp = L(V))) { return flatbuffers_not_found; }\
  --b__tmp;\
  while (a__tmp < b__tmp) {\
    m__tmp = a__tmp + ((b__tmp - a__tmp) >> 1);\
    v__tmp = A(E(V, m__tmp));\
    if ((D(v__tmp, (K), (Kn))) < 0) {\
      a__tmp = m__tmp + 1;\
    } else {\
      b__tmp = m__tmp;\
    }\
  }\
  if (a__tmp == b__tmp) {\
    v__tmp = A(E(V, a__tmp));\
    if (D(v__tmp, (K), (Kn)) == 0) {\
       return a__tmp;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_find_by_scalar_field(A, V, E, L, K, T)\
__flatbuffers_find_by_field(A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_find_by_string_field(A, V, E, L, K)\
__flatbuffers_find_by_field(A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_find_by_string_n_field(A, V, E, L, K, Kn)\
__flatbuffers_find_by_field(A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_define_find_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec__tmp, TK key__tmp)\
__flatbuffers_find_by_scalar_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, TK)
#define __flatbuffers_define_scalar_find(N, T)\
static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, T key__tmp)\
__flatbuffers_find_by_scalar_field(__flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)
#define __flatbuffers_define_find_by_string_field(N, NK) \
/* Note: find only works on vectors sorted by this field. */\
static inline size_t N ## _vec_find_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\
__flatbuffers_find_by_string_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\
static inline size_t N ## _vec_find_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
__flatbuffers_find_by_string_n_field(N ## _ ## NK, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)
#define __flatbuffers_define_default_find_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, TK key__tmp)\
{ return N ## _vec_find_by_ ## NK(vec__tmp, key__tmp); }
#define __flatbuffers_define_default_find_by_string_field(N, NK) \
static inline size_t N ## _vec_find(N ## _vec_t vec__tmp, const char *s__tmp)\
{ return N ## _vec_find_by_ ## NK(vec__tmp, s__tmp); }\
static inline size_t N ## _vec_find_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
{ return N ## _vec_find_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }
/* A = identity if searching scalar vectors rather than key fields. */
/* Returns lowest matching index or not_found. */
#define __flatbuffers_scan_by_field(b, e, A, V, E, L, K, Kn, T, D)\
{ T v__tmp; size_t i__tmp;\
  for (i__tmp = b; i__tmp < e; ++i__tmp) {\
    v__tmp = A(E(V, i__tmp));\
    if (D(v__tmp, (K), (Kn)) == 0) {\
       return i__tmp;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_rscan_by_field(b, e, A, V, E, L, K, Kn, T, D)\
{ T v__tmp; size_t i__tmp = e;\
  while (i__tmp-- > b) {\
    v__tmp = A(E(V, i__tmp));\
    if (D(v__tmp, (K), (Kn)) == 0) {\
       return i__tmp;\
    }\
  }\
  return flatbuffers_not_found;\
}
#define __flatbuffers_scan_by_scalar_field(b, e, A, V, E, L, K, T)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_scan_by_string_field(b, e, A, V, E, L, K)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_scan_by_string_n_field(b, e, A, V, E, L, K, Kn)\
__flatbuffers_scan_by_field(b, e, A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_rscan_by_scalar_field(b, e, A, V, E, L, K, T)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, 0, T, __flatbuffers_scalar_cmp)
#define __flatbuffers_rscan_by_string_field(b, e, A, V, E, L, K)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, 0, flatbuffers_string_t, __flatbuffers_string_cmp)
#define __flatbuffers_rscan_by_string_n_field(b, e, A, V, E, L, K, Kn)\
__flatbuffers_rscan_by_field(b, e, A, V, E, L, K, Kn, flatbuffers_string_t, __flatbuffers_string_n_cmp)
#define __flatbuffers_define_scan_by_scalar_field(N, NK, T)\
static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec__tmp, T key__tmp)\
__flatbuffers_scan_by_scalar_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\
__flatbuffers_scan_by_scalar_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec__tmp, T key__tmp)\
__flatbuffers_rscan_by_scalar_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\
__flatbuffers_rscan_by_scalar_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)
#define __flatbuffers_define_scalar_scan(N, T)\
static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, T key__tmp)\
__flatbuffers_scan_by_scalar_field(0, N ## _vec_len(vec__tmp), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\
__flatbuffers_scan_by_scalar_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, T key__tmp)\
__flatbuffers_rscan_by_scalar_field(0, N ## _vec_len(vec__tmp), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, T key__tmp)\
__flatbuffers_rscan_by_scalar_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), __flatbuffers_identity, vec__tmp, N ## _vec_at, N ## _vec_len, key__tmp, T)
#define __flatbuffers_define_scan_by_string_field(N, NK) \
static inline size_t N ## _vec_scan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\
__flatbuffers_scan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\
static inline size_t N ## _vec_scan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
__flatbuffers_scan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\
static inline size_t N ## _vec_scan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\
__flatbuffers_scan_by_string_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\
static inline size_t N ## _vec_scan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\
__flatbuffers_scan_by_string_n_field(begin__tmp, __flatbuffers_min( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\
static inline size_t N ## _vec_rscan_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp)\
__flatbuffers_rscan_by_string_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\
static inline size_t N ## _vec_rscan_n_by_ ## NK(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
__flatbuffers_rscan_by_string_n_field(0, N ## _vec_len(vec__tmp), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)\
static inline size_t N ## _vec_rscan_ex_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\
__flatbuffers_rscan_by_string_field(begin__tmp, __flatbuffers_min(end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp)\
static inline size_t N ## _vec_rscan_ex_n_by_ ## NK(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\
__flatbuffers_rscan_by_string_n_field(begin__tmp, __flatbuffers_min( end__tmp, N ## _vec_len(vec__tmp)), N ## _ ## NK ## _get, vec__tmp, N ## _vec_at, N ## _vec_len, s__tmp, n__tmp)
#define __flatbuffers_define_default_scan_by_scalar_field(N, NK, TK)\
static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, TK key__tmp)\
{ return N ## _vec_scan_by_ ## NK(vec__tmp, key__tmp); }\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\
{ return N ## _vec_scan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, key__tmp); }\
static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, TK key__tmp)\
{ return N ## _vec_rscan_by_ ## NK(vec__tmp, key__tmp); }\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, TK key__tmp)\
{ return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, key__tmp); }
#define __flatbuffers_define_default_scan_by_string_field(N, NK) \
static inline size_t N ## _vec_scan(N ## _vec_t vec__tmp, const char *s__tmp)\
{ return N ## _vec_scan_by_ ## NK(vec__tmp, s__tmp); }\
static inline size_t N ## _vec_scan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
{ return N ## _vec_scan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\
static inline size_t N ## _vec_scan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\
{ return N ## _vec_scan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\
static inline size_t N ## _vec_scan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\
{ return N ## _vec_scan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }\
static inline size_t N ## _vec_rscan(N ## _vec_t vec__tmp, const char *s__tmp)\
{ return N ## _vec_rscan_by_ ## NK(vec__tmp, s__tmp); }\
static inline size_t N ## _vec_rscan_n(N ## _vec_t vec__tmp, const char *s__tmp, size_t n__tmp)\
{ return N ## _vec_rscan_n_by_ ## NK(vec__tmp, s__tmp, n__tmp); }\
static inline size_t N ## _vec_rscan_ex(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp)\
{ return N ## _vec_rscan_ex_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp); }\
static inline size_t N ## _vec_rscan_ex_n(N ## _vec_t vec__tmp, size_t begin__tmp, size_t end__tmp, const char *s__tmp, size_t n__tmp)\
{ return N ## _vec_rscan_ex_n_by_ ## NK(vec__tmp, begin__tmp, end__tmp, s__tmp, n__tmp); }
#define __flatbuffers_heap_sort(N, X, A, E, L, TK, TE, D, S)\
static inline void __ ## N ## X ## __heap_sift_down(\
        N ## _mutable_vec_t vec__tmp, size_t start__tmp, size_t end__tmp)\
{ size_t child__tmp, root__tmp; TK v1__tmp, v2__tmp, vroot__tmp;\
  root__tmp = start__tmp;\
  while ((root__tmp << 1) <= end__tmp) {\
    child__tmp = root__tmp << 1;\
    if (child__tmp < end__tmp) {\
      v1__tmp = A(E(vec__tmp, child__tmp));\
      v2__tmp = A(E(vec__tmp, child__tmp + 1));\
      if (D(v1__tmp, v2__tmp) < 0) {\
        child__tmp++;\
      }\
    }\
    vroot__tmp = A(E(vec__tmp, root__tmp));\
    v1__tmp = A(E(vec__tmp, child__tmp));\
    if (D(vroot__tmp, v1__tmp) < 0) {\
      S(vec__tmp, root__tmp, child__tmp, TE);\
      root__tmp = child__tmp;\
    } else {\
      return;\
    }\
  }\
}\
static inline void __ ## N ## X ## __heap_sort(N ## _mutable_vec_t vec__tmp)\
{ size_t start__tmp, end__tmp, size__tmp;\
  size__tmp = L(vec__tmp); if (size__tmp == 0) return; end__tmp = size__tmp - 1; start__tmp = size__tmp >> 1;\
  do { __ ## N ## X ## __heap_sift_down(vec__tmp, start__tmp, end__tmp); } while (start__tmp--);\
  while (end__tmp > 0) { \
    S(vec__tmp, 0, end__tmp, TE);\
    __ ## N ## X ## __heap_sift_down(vec__tmp, 0, --end__tmp); } }
#define __flatbuffers_define_sort_by_field(N, NK, TK, TE, D, S)\
  __flatbuffers_heap_sort(N, _sort_by_ ## NK, N ## _ ## NK ## _get, N ## _vec_at, N ## _vec_len, TK, TE, D, S)\
static inline void N ## _vec_sort_by_ ## NK(N ## _mutable_vec_t vec__tmp)\
{ __ ## N ## _sort_by_ ## NK ## __heap_sort(vec__tmp); }
#define __flatbuffers_define_sort(N, TK, TE, D, S)\
__flatbuffers_heap_sort(N, , __flatbuffers_identity, N ## _vec_at, N ## _vec_len, TK, TE, D, S)\
static inline void N ## _vec_sort(N ## _mutable_vec_t vec__tmp) { __ ## N ## __heap_sort(vec__tmp); }
#define __flatbuffers_scalar_diff(x, y) ((x) < (y) ? -1 : (x) > (y))
#define __flatbuffers_string_diff(x, y) __flatbuffers_string_n_cmp((x), (const char *)(y), flatbuffers_string_len(y))
#define __flatbuffers_value_swap(vec, a, b, TE) { TE x__tmp = vec[b]; vec[b] = vec[a]; vec[a] = x__tmp; }
#define __flatbuffers_uoffset_swap(vec, a, b, TE)\
{ TE ta__tmp, tb__tmp, d__tmp;\
  d__tmp = (TE)((a - b) * sizeof(vec[0]));\
  ta__tmp =  __flatbuffers_uoffset_read_from_pe(vec + b) - d__tmp;\
  tb__tmp =  __flatbuffers_uoffset_read_from_pe(vec + a) + d__tmp;\
  __flatbuffers_uoffset_write_to_pe(vec + a, ta__tmp);\
  __flatbuffers_uoffset_write_to_pe(vec + b, tb__tmp); }
#define __flatbuffers_scalar_swap(vec, a, b, TE) __flatbuffers_value_swap(vec, a, b, TE)
#define __flatbuffers_string_swap(vec, a, b, TE) __flatbuffers_uoffset_swap(vec, a, b, TE)
#define __flatbuffers_struct_swap(vec, a, b, TE) __flatbuffers_value_swap(vec, a, b, TE)
#define __flatbuffers_table_swap(vec, a, b, TE) __flatbuffers_uoffset_swap(vec, a, b, TE)
#define __flatbuffers_define_struct_sort_by_scalar_field(N, NK, TK, TE)\
  __flatbuffers_define_sort_by_field(N, NK, TK, TE, __flatbuffers_scalar_diff, __flatbuffers_struct_swap)
#define __flatbuffers_define_table_sort_by_scalar_field(N, NK, TK)\
  __flatbuffers_define_sort_by_field(N, NK, TK, flatbuffers_uoffset_t, __flatbuffers_scalar_diff, __flatbuffers_table_swap)
#define __flatbuffers_define_table_sort_by_string_field(N, NK)\
  __flatbuffers_define_sort_by_field(N, NK, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_table_swap)
#define __flatbuffers_define_scalar_sort(N, T) __flatbuffers_define_sort(N, T, T, __flatbuffers_scalar_diff, __flatbuffers_scalar_swap)
#define __flatbuffers_define_string_sort() __flatbuffers_define_sort(flatbuffers_string, flatbuffers_string_t, flatbuffers_uoffset_t, __flatbuffers_string_diff, __flatbuffers_string_swap)
#define __flatbuffers_sort_vector_field(N, NK, T, t)\
{ T ## _mutable_vec_t v__tmp = (T ## _mutable_vec_t) N ## _ ## NK ## _get(t);\
  if (v__tmp) T ## _vec_sort(v__tmp); }
#define __flatbuffers_sort_table_field(N, NK, T, t)\
{ T ## _sort((T ## _mutable_table_t)N ## _ ## NK ## _get(t)); }
#define __flatbuffers_sort_union_field(N, NK, T, t)\
{ T ## _sort(T ## _mutable_union_cast(N ## _ ## NK ## _union(t))); }
#define __flatbuffers_sort_table_vector_field_elements(N, NK, T, t)\
{ T ## _vec_t v__tmp = N ## _ ## NK ## _get(t); size_t i__tmp, n__tmp;\
  n__tmp = T ## _vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\
  T ## _sort((T ## _mutable_table_t)T ## _vec_at(v__tmp, i__tmp)); }}
#define __flatbuffers_sort_union_vector_field_elements(N, NK, T, t)\
{ T ## _union_vec_t v__tmp = N ## _ ## NK ## _union(t); size_t i__tmp, n__tmp;\
  n__tmp = T ## _union_vec_len(v__tmp); for (i__tmp = 0; i__tmp < n__tmp; ++i__tmp) {\
  T ## _sort(T ## _mutable_union_cast(T ## _union_vec_at(v__tmp, i__tmp))); }}
#define __flatbuffers_define_scalar_vector(N, T)\
typedef const T *N ## _vec_t;\
typedef T *N ## _mutable_vec_t;\
__flatbuffers_define_scalar_vec_len(N)\
__flatbuffers_define_scalar_vec_at(N, T)\
__flatbuffers_define_scalar_find(N, T)\
__flatbuffers_define_scalar_scan(N, T)\
__flatbuffers_define_scalar_sort(N, T)

#define __flatbuffers_define_integer_type(N, T, W)\
__flatcc_define_integer_accessors(N, T, W, flatbuffers_endian)\
__flatbuffers_define_scalar_vector(N, T)
__flatbuffers_define_scalar_vector(flatbuffers_bool, flatbuffers_bool_t)
__flatbuffers_define_scalar_vector(flatbuffers_char, char)
__flatbuffers_define_scalar_vector(flatbuffers_uint8, uint8_t)
__flatbuffers_define_scalar_vector(flatbuffers_int8, int8_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint16, uint16_t)
__flatbuffers_define_scalar_vector(flatbuffers_int16, int16_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint32, uint32_t)
__flatbuffers_define_scalar_vector(flatbuffers_int32, int32_t)
__flatbuffers_define_scalar_vector(flatbuffers_uint64, uint64_t)
__flatbuffers_define_scalar_vector(flatbuffers_int64, int64_t)
__flatbuffers_define_scalar_vector(flatbuffers_float, float)
__flatbuffers_define_scalar_vector(flatbuffers_double, double)
__flatbuffers_define_scalar_vector(flatbuffers_union_type, flatbuffers_union_type_t)
static inline size_t flatbuffers_string_vec_find(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_find_by_string_field(__flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_find_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_find_by_string_n_field(__flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_scan(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_scan_by_string_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_scan_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_scan_by_string_n_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_scan_ex(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s)
__flatbuffers_scan_by_string_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_scan_ex_n(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s, size_t n)
__flatbuffers_scan_by_string_n_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_rscan(flatbuffers_string_vec_t vec, const char *s)
__flatbuffers_rscan_by_string_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_rscan_n(flatbuffers_string_vec_t vec, const char *s, size_t n)
__flatbuffers_rscan_by_string_n_field(0, flatbuffers_string_vec_len(vec), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
static inline size_t flatbuffers_string_vec_rscan_ex(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s)
__flatbuffers_rscan_by_string_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s)
static inline size_t flatbuffers_string_vec_rscan_ex_n(flatbuffers_string_vec_t vec, size_t begin, size_t end, const char *s, size_t n)
__flatbuffers_rscan_by_string_n_field(begin, __flatbuffers_min(end, flatbuffers_string_vec_len(vec)), __flatbuffers_identity, vec, flatbuffers_string_vec_at, flatbuffers_string_vec_len, s, n)
__flatbuffers_define_string_sort()
#define __flatbuffers_define_struct_scalar_fixed_array_field(N, NK, TK, T, L)\
static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\
{ if (!t__tmp || i__tmp >= L) return 0;\
  return __flatbuffers_read_scalar(TK, &(t__tmp->NK[i__tmp])); }\
static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\
{ return t__tmp ? t__tmp->NK : 0; }\
static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\
static inline T N ## _ ## NK (N ## _struct_t t__tmp, size_t i__tmp)\
{ return N ## _ ## NK ## _get(t__tmp, i__tmp); }
#define __flatbuffers_define_struct_struct_fixed_array_field(N, NK, T, L)\
static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp, size_t i__tmp)\
{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }static inline T N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\
{ return t__tmp ? t__tmp->NK : 0; }\
static inline size_t N ## _ ## NK ## _get_len(void) { return L; }\
static inline T N ## _ ## NK(N ## _struct_t t__tmp, size_t i__tmp)\
{ if (!t__tmp || i__tmp >= L) return 0; return t__tmp->NK + i__tmp; }
#define __flatbuffers_define_struct_scalar_field(N, NK, TK, T)\
static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp)\
{ return t__tmp ? __flatbuffers_read_scalar(TK, &(t__tmp->NK)) : 0; }\
static inline const T *N ## _ ## NK ## _get_ptr(N ## _struct_t t__tmp)\
{ return t__tmp ? &(t__tmp->NK) : 0; }\
static inline T N ## _ ## NK (N ## _struct_t t__tmp)\
{ return t__tmp ? __flatbuffers_read_scalar(TK, &(t__tmp->NK)) : 0; }\
__flatbuffers_define_scan_by_scalar_field(N, NK, T)
#define __flatbuffers_define_struct_struct_field(N, NK, T)\
static inline T N ## _ ## NK ## _get(N ## _struct_t t__tmp) { return t__tmp ? &(t__tmp->NK) : 0; }\
static inline T N ## _ ## NK (N ## _struct_t t__tmp) { return t__tmp ? &(t__tmp->NK) : 0; }
/* If fid is null, the function returns true without testing as buffer is not expected to have any id. */
static inline int flatbuffers_has_identifier(const void *buffer, const char *fid)
{ flatbuffers_thash_t id, id2 = 0; if (fid == 0) { return 1; };
  id2 = flatbuffers_type_hash_from_string(fid);
  id = __flatbuffers_thash_read_from_pe(((flatbuffers_uoffset_t *)buffer) + 1);
  return id2 == 0 || id == id2; }
static inline int flatbuffers_has_type_hash(const void *buffer, flatbuffers_thash_t thash)
{ return thash == 0 || (__flatbuffers_thash_read_from_pe((flatbuffers_uoffset_t *)buffer + 1) == thash); }

static inline flatbuffers_thash_t flatbuffers_get_type_hash(const void *buffer)
{ return __flatbuffers_thash_read_from_pe((flatbuffers_uoffset_t *)buffer + 1); }

#define flatbuffers_verify_endian() flatbuffers_has_identifier("\x00\x00\x00\x00" "1234", "1234")
static inline void *flatbuffers_read_size_prefix(void *b, size_t *size_out)
{ if (size_out) { *size_out = (size_t)__flatbuffers_uoffset_read_from_pe(b); }
  return (uint8_t *)b + sizeof(flatbuffers_uoffset_t); }
/* Null file identifier accepts anything, otherwise fid should be 4 characters. */
#define __flatbuffers_read_root(T, K, buffer, fid)\
  ((!buffer || !flatbuffers_has_identifier(buffer, fid)) ? 0 :\
  ((T ## _ ## K ## t)(((uint8_t *)buffer) +\
    __flatbuffers_uoffset_read_from_pe(buffer))))
#define __flatbuffers_read_typed_root(T, K, buffer, thash)\
  ((!buffer || !flatbuffers_has_type_hash(buffer, thash)) ? 0 :\
  ((T ## _ ## K ## t)(((uint8_t *)buffer) +\
    __flatbuffers_uoffset_read_from_pe(buffer))))
#define __flatbuffers_nested_buffer_as_root(C, N, T, K)\
static inline T ## _ ## K ## t C ## _ ## N ## _as_root_with_identifier(C ## _ ## table_t t__tmp, const char *fid__tmp)\
{ const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, fid__tmp); }\
static inline T ## _ ## K ## t C ## _ ## N ## _as_typed_root(C ## _ ## table_t t__tmp)\
{ const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, C ## _ ## type_identifier); }\
static inline T ## _ ## K ## t C ## _ ## N ## _as_root(C ## _ ## table_t t__tmp)\
{ const char *fid__tmp = T ## _file_identifier;\
  const uint8_t *buffer__tmp = C ## _ ## N(t__tmp); return __flatbuffers_read_root(T, K, buffer__tmp, fid__tmp); }
#define __flatbuffers_buffer_as_root(N, K)\
static inline N ## _ ## K ## t N ## _as_root_with_identifier(const void *buffer__tmp, const char *fid__tmp)\
{ return __flatbuffers_read_root(N, K, buffer__tmp, fid__tmp); }\
static inline N ## _ ## K ## t N ## _as_root_with_type_hash(const void *buffer__tmp, flatbuffers_thash_t thash__tmp)\
{ return __flatbuffers_read_typed_root(N, K, buffer__tmp, thash__tmp); }\
static inline N ## _ ## K ## t N ## _as_root(const void *buffer__tmp)\
{ const char *fid__tmp = N ## _file_identifier;\
  return __flatbuffers_read_root(N, K, buffer__tmp, fid__tmp); }\
static inline N ## _ ## K ## t N ## _as_typed_root(const void *buffer__tmp)\
{ return __flatbuffers_read_typed_root(N, K, buffer__tmp, N ## _type_hash); }
#define __flatbuffers_struct_as_root(N) __flatbuffers_buffer_as_root(N, struct_)
#define __flatbuffers_table_as_root(N) __flatbuffers_buffer_as_root(N, table_)

#include "flatcc/flatcc_epilogue.h"
#endif /* FLATBUFFERS_COMMON_H */
#ifndef FLATBUFFERS_COMMON_BUILDER_H
#define FLATBUFFERS_COMMON_BUILDER_H

/* Generated by flatcc 0.6.1-dev FlatBuffers schema compiler for C by dvide.com */

/* Common FlatBuffers build functionality for C. */

#include "flatcc/flatcc_prologue.h"
#ifndef FLATBUILDER_H
#include "flatcc/flatcc_builder.h"
#endif
typedef flatcc_builder_t flatbuffers_builder_t;
typedef flatcc_builder_ref_t flatbuffers_ref_t;
typedef flatcc_builder_ref_t flatbuffers_vec_ref_t;
typedef flatcc_builder_union_ref_t flatbuffers_union_ref_t;
typedef flatcc_builder_union_vec_ref_t flatbuffers_union_vec_ref_t;
/* integer return code (ref and ptr always fail on 0) */
#define flatbuffers_failed(x) ((x) < 0)
typedef flatbuffers_ref_t flatbuffers_root_t;
#define flatbuffers_root(ref) ((flatbuffers_root_t)(ref))

#define __flatbuffers_memoize_begin(B, src)\
do { flatcc_builder_ref_t _ref; if ((_ref = flatcc_builder_refmap_find((B), (src)))) return _ref; } while (0)
#define __flatbuffers_memoize_end(B, src, op) do { return flatcc_builder_refmap_insert((B), (src), (op)); } while (0)
#define __flatbuffers_memoize(B, src, op) do { __flatbuffers_memoize_begin(B, src); __flatbuffers_memoize_end(B, src, op); } while (0)

#define __flatbuffers_build_buffer(NS)\
typedef NS ## ref_t NS ## buffer_ref_t;\
static inline int NS ## buffer_start(NS ## builder_t *B, const NS ##fid_t fid)\
{ return flatcc_builder_start_buffer(B, fid, 0, 0); }\
static inline int NS ## buffer_start_with_size(NS ## builder_t *B, const NS ##fid_t fid)\
{ return flatcc_builder_start_buffer(B, fid, 0, flatcc_builder_with_size); }\
static inline int NS ## buffer_start_aligned(NS ## builder_t *B, NS ##fid_t fid, uint16_t block_align)\
{ return flatcc_builder_start_buffer(B, fid, block_align, 0); }\
static inline int NS ## buffer_start_aligned_with_size(NS ## builder_t *B, NS ##fid_t fid, uint16_t block_align)\
{ return flatcc_builder_start_buffer(B, fid, block_align, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t NS ## buffer_end(NS ## builder_t *B, NS ## ref_t root)\
{ return flatcc_builder_end_buffer(B, root); }

#define __flatbuffers_build_table_root(NS, N, FID, TFID)\
static inline int N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, FID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? -1 : N ## _start(B); }\
static inline int N ## _start_as_typed_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, TFID) ? -1 : N ## _start(B); }\
static inline NS ## buffer_ref_t N ## _end_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _create_as_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start(B, FID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start_with_size(B, FID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start(B, TFID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ if (NS ## buffer_start_with_size(B, TFID)) return 0; return NS ## buffer_end(B, N ## _create(B __ ## N ## _call_args)); }\
static inline NS ## buffer_ref_t N ## _clone_as_root(NS ## builder_t *B, N ## _table_t t)\
{ if (NS ## buffer_start(B, FID)) return 0; return NS ## buffer_end(B, N ## _clone(B, t)); }\
static inline NS ## buffer_ref_t N ## _clone_as_root_with_size(NS ## builder_t *B, N ## _table_t t)\
{ if (NS ## buffer_start_with_size(B, FID)) return 0; return NS ## buffer_end(B, N ## _clone(B, t)); }\
static inline NS ## buffer_ref_t N ## _clone_as_typed_root(NS ## builder_t *B, N ## _table_t t)\
{ if (NS ## buffer_start(B, TFID)) return 0;return NS ## buffer_end(B, N ## _clone(B, t)); }\
static inline NS ## buffer_ref_t N ## _clone_as_typed_root_with_size(NS ## builder_t *B, N ## _table_t t)\
{ if (NS ## buffer_start_with_size(B, TFID)) return 0; return NS ## buffer_end(B, N ## _clone(B, t)); }

#define __flatbuffers_build_table_prolog(NS, N, FID, TFID)\
__flatbuffers_build_table_vector_ops(NS, N ## _vec, N)\
__flatbuffers_build_table_root(NS, N, FID, TFID)

#define __flatbuffers_build_struct_root(NS, N, A, FID, TFID)\
static inline N ## _t *N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, FID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? 0 : N ## _start(B); }\
static inline N ## _t *N ## _start_as_typed_root_with_size(NS ## builder_t *B)\
{ return NS ## buffer_start_with_size(B, TFID) ? 0 : N ## _start(B); }\
static inline NS ## buffer_ref_t N ## _end_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end(B)); }\
static inline NS ## buffer_ref_t N ## _end_pe_as_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end_pe(B)); }\
static inline NS ## buffer_ref_t N ## _end_pe_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_end(B, N ## _end_pe(B)); }\
static inline NS ## buffer_ref_t N ## _create_as_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, FID, 0,\
  N ## _create(B __ ## N ## _call_args), A, 0); }\
static inline NS ## buffer_ref_t N ## _create_as_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, FID, 0,\
  N ## _create(B __ ## N ## _call_args), A, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, TFID, 0,\
  N ## _create(B __ ## N ## _call_args), A, 0); }\
static inline NS ## buffer_ref_t N ## _create_as_typed_root_with_size(NS ## builder_t *B __ ## N ## _formal_args)\
{ return flatcc_builder_create_buffer(B, TFID, 0,\
  N ## _create(B __ ## N ## _call_args), A, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t N ## _clone_as_root(NS ## builder_t *B, N ## _struct_t p)\
{ return flatcc_builder_create_buffer(B, FID, 0, N ## _clone(B, p), A, 0); }\
static inline NS ## buffer_ref_t N ## _clone_as_root_with_size(NS ## builder_t *B, N ## _struct_t p)\
{ return flatcc_builder_create_buffer(B, FID, 0, N ## _clone(B, p), A, flatcc_builder_with_size); }\
static inline NS ## buffer_ref_t N ## _clone_as_typed_root(NS ## builder_t *B, N ## _struct_t p)\
{ return flatcc_builder_create_buffer(B, TFID, 0, N ## _clone(B, p), A, 0); }\
static inline NS ## buffer_ref_t N ## _clone_as_typed_root_with_size(NS ## builder_t *B, N ## _struct_t p)\
{ return flatcc_builder_create_buffer(B, TFID, 0, N ## _clone(B, p), A, flatcc_builder_with_size); }

#define __flatbuffers_build_nested_table_root(NS, N, TN, FID, TFID)\
static inline int N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? -1 : TN ## _start(B); }\
static inline int N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, TFID) ? -1 : TN ## _start(B); }\
static inline int N ## _end_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_as_typed_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align ? align : 8, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _typed_nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align ? align : 8, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _clone_as_root(NS ## builder_t *B, TN ## _table_t t)\
{ return N ## _add(B, TN ## _clone_as_root(B, t)); }\
static inline int N ## _clone_as_typed_root(NS ## builder_t *B, TN ## _table_t t)\
{ return N ## _add(B, TN ## _clone_as_typed_root(B, t)); }

#define __flatbuffers_build_nested_struct_root(NS, N, TN, A, FID, TFID)\
static inline TN ## _t *N ## _start_as_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : TN ## _start(B); }\
static inline TN ## _t *N ## _start_as_typed_root(NS ## builder_t *B)\
{ return NS ## buffer_start(B, FID) ? 0 : TN ## _start(B); }\
static inline int N ## _end_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_as_typed_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end(B))); }\
static inline int N ## _end_pe_as_root(NS ## builder_t *B)\
{ return N ## _add(B, NS ## buffer_end(B, TN ## _end_pe(B))); }\
static inline int N ## _create_as_root(NS ## builder_t *B __ ## TN ## _formal_args)\
{ return N ## _add(B, flatcc_builder_create_buffer(B, FID, 0,\
  TN ## _create(B __ ## TN ## _call_args), A, flatcc_builder_is_nested)); }\
static inline int N ## _create_as_typed_root(NS ## builder_t *B __ ## TN ## _formal_args)\
{ return N ## _add(B, flatcc_builder_create_buffer(B, TFID, 0,\
  TN ## _create(B __ ## TN ## _call_args), A, flatcc_builder_is_nested)); }\
static inline int N ## _nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align < A ? A : align, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _typed_nest(NS ## builder_t *B, void *data, size_t size, uint16_t align)\
{ return N ## _add(B, flatcc_builder_create_vector(B, data, size, 1,\
  align < A ? A : align, FLATBUFFERS_COUNT_MAX(1))); }\
static inline int N ## _clone_as_root(NS ## builder_t *B, TN ## _struct_t p)\
{ return N ## _add(B, TN ## _clone_as_root(B, p)); }\
static inline int N ## _clone_as_typed_root(NS ## builder_t *B, TN ## _struct_t p)\
{ return N ## _add(B, TN ## _clone_as_typed_root(B, p)); }

#define __flatbuffers_build_vector_ops(NS, V, N, TN, T)\
static inline T *V ## _extend(NS ## builder_t *B, size_t len)\
{ return (T *)flatcc_builder_extend_vector(B, len); }\
static inline T *V ## _append(NS ## builder_t *B, const T *data, size_t len)\
{ return (T *)flatcc_builder_append_vector(B, data, len); }\
static inline int V ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_vector(B, len); }\
static inline T *V ## _edit(NS ## builder_t *B)\
{ return (T *)flatcc_builder_vector_edit(B); }\
static inline size_t V ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_vector_count(B); }\
static inline T *V ## _push(NS ## builder_t *B, const T *p)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? (memcpy(_p, p, TN ## __size()), _p) : 0; }\
static inline T *V ## _push_copy(NS ## builder_t *B, const T *p)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? TN ## _copy(_p, p) : 0; }\
static inline T *V ## _push_clone(NS ## builder_t *B, const T *p)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? TN ## _copy(_p, p) : 0; }\
static inline T *V ## _push_create(NS ## builder_t *B __ ## TN ## _formal_args)\
{ T *_p; return (_p = (T *)flatcc_builder_extend_vector(B, 1)) ? TN ## _assign(_p __ ## TN ## _call_args) : 0; }

#define __flatbuffers_build_vector(NS, N, T, S, A)\
typedef NS ## ref_t N ## _vec_ref_t;\
static inline int N ## _vec_start(NS ## builder_t *B)\
{ return flatcc_builder_start_vector(B, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_end_pe(NS ## builder_t *B)\
{ return flatcc_builder_end_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { size_t i, n; T *p = (T *)flatcc_builder_vector_edit(B);\
    for (i = 0, n = flatcc_builder_vector_count(B); i < n; ++i)\
    { N ## _to_pe(N ## __ptr_add(p, i)); }} return flatcc_builder_end_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_create_pe(NS ## builder_t *B, const T *data, size_t len)\
{ return flatcc_builder_create_vector(B, data, len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_create(NS ## builder_t *B, const T *data, size_t len)\
{ if (!NS ## is_native_pe()) { size_t i; T *p; int ret = flatcc_builder_start_vector(B, S, A, FLATBUFFERS_COUNT_MAX(S)); if (ret) { return ret; }\
  p = (T *)flatcc_builder_extend_vector(B, len); if (!p) return 0;\
  for (i = 0; i < len; ++i) { N ## _copy_to_pe(N ## __ptr_add(p, i), N ## __const_ptr_add(data, i)); }\
  return flatcc_builder_end_vector(B); } else return flatcc_builder_create_vector(B, data, len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
static inline N ## _vec_ref_t N ## _vec_clone(NS ## builder_t *B, N ##_vec_t vec)\
{ __flatbuffers_memoize(B, vec, flatcc_builder_create_vector(B, vec, N ## _vec_len(vec), S, A, FLATBUFFERS_COUNT_MAX(S))); }\
static inline N ## _vec_ref_t N ## _vec_slice(NS ## builder_t *B, N ##_vec_t vec, size_t index, size_t len)\
{ size_t n = N ## _vec_len(vec); if (index >= n) index = n; n -= index; if (len > n) len = n;\
  return flatcc_builder_create_vector(B, N ## __const_ptr_add(vec, index), len, S, A, FLATBUFFERS_COUNT_MAX(S)); }\
__flatbuffers_build_vector_ops(NS, N ## _vec, N, N, T)

#define __flatbuffers_build_union_vector_ops(NS, V, N, TN)\
static inline TN ## _union_ref_t *V ## _extend(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_extend_union_vector(B, len); }\
static inline TN ## _union_ref_t *V ## _append(NS ## builder_t *B, const TN ## _union_ref_t *data, size_t len)\
{ return flatcc_builder_append_union_vector(B, data, len); }\
static inline int V ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_union_vector(B, len); }\
static inline TN ## _union_ref_t *V ## _edit(NS ## builder_t *B)\
{ return (TN ## _union_ref_t *) flatcc_builder_union_vector_edit(B); }\
static inline size_t V ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_union_vector_count(B); }\
static inline TN ## _union_ref_t *V ## _push(NS ## builder_t *B, const TN ## _union_ref_t ref)\
{ return flatcc_builder_union_vector_push(B, ref); }\
static inline TN ## _union_ref_t *V ## _push_clone(NS ## builder_t *B, TN ## _union_t u)\
{ return TN ## _vec_push(B, TN ## _clone(B, u)); }

#define __flatbuffers_build_union_vector(NS, N)\
static inline int N ## _vec_start(NS ## builder_t *B)\
{ return flatcc_builder_start_union_vector(B); }\
static inline N ## _union_vec_ref_t N ## _vec_end(NS ## builder_t *B)\
{ return flatcc_builder_end_union_vector(B); }\
static inline N ## _union_vec_ref_t N ## _vec_create(NS ## builder_t *B, const N ## _union_ref_t *data, size_t len)\
{ return flatcc_builder_create_union_vector(B, data, len); }\
__flatbuffers_build_union_vector_ops(NS, N ## _vec, N, N)\
/* Preserves DAG structure separately for type and value vector, so a type vector could be shared for many value vectors. */\
static inline N ## _union_vec_ref_t N ## _vec_clone(NS ## builder_t *B, N ##_union_vec_t vec)\
{ N ## _union_vec_ref_t _uvref, _ret = { 0, 0 }; NS ## union_ref_t _uref; size_t _i, _len;\
  if (vec.type == 0) return _ret;\
  _uvref.type = flatcc_builder_refmap_find(B, vec.type); _uvref.value = flatcc_builder_refmap_find(B, vec.value);\
  _len = N ## _union_vec_len(vec); if (_uvref.type == 0) {\
  _uvref.type = flatcc_builder_refmap_insert(B, vec.type, (flatcc_builder_create_type_vector(B, vec.type, _len))); }\
  if (_uvref.type == 0) return _ret; if (_uvref.value == 0) {\
  if (flatcc_builder_start_offset_vector(B)) return _ret;\
  for (_i = 0; _i < _len; ++_i) { _uref = N ## _clone(B, N ## _union_vec_at(vec, _i));\
    if (!_uref.value || !(flatcc_builder_offset_vector_push(B, _uref.value))) return _ret; }\
  _uvref.value = flatcc_builder_refmap_insert(B, vec.value, flatcc_builder_end_offset_vector(B));\
  if (_uvref.value == 0) return _ret; } return _uvref; }

#define __flatbuffers_build_string_vector_ops(NS, N)\
static inline int N ## _push_start(NS ## builder_t *B)\
{ return NS ## string_start(B); }\
static inline NS ## string_ref_t *N ## _push_end(NS ## builder_t *B)\
{ return NS ## string_vec_push(B, NS ## string_end(B)); }\
static inline NS ## string_ref_t *N ## _push_create(NS ## builder_t *B, const char *s, size_t len)\
{ return NS ## string_vec_push(B, NS ## string_create(B, s, len)); }\
static inline NS ## string_ref_t *N ## _push_create_str(NS ## builder_t *B, const char *s)\
{ return NS ## string_vec_push(B, NS ## string_create_str(B, s)); }\
static inline NS ## string_ref_t *N ## _push_create_strn(NS ## builder_t *B, const char *s, size_t max_len)\
{ return NS ## string_vec_push(B, NS ## string_create_strn(B, s, max_len)); }\
static inline NS ## string_ref_t *N ## _push_clone(NS ## builder_t *B, NS ## string_t string)\
{ return NS ## string_vec_push(B, NS ## string_clone(B, string)); }\
static inline NS ## string_ref_t *N ## _push_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ return NS ## string_vec_push(B, NS ## string_slice(B, string, index, len)); }

#define __flatbuffers_build_table_vector_ops(NS, N, TN)\
static inline int N ## _push_start(NS ## builder_t *B)\
{ return TN ## _start(B); }\
static inline TN ## _ref_t *N ## _push_end(NS ## builder_t *B)\
{ return N ## _push(B, TN ## _end(B)); }\
static inline TN ## _ref_t *N ## _push_create(NS ## builder_t *B __ ## TN ##_formal_args)\
{ return N ## _push(B, TN ## _create(B __ ## TN ## _call_args)); }

#define __flatbuffers_build_offset_vector_ops(NS, V, N, TN)\
static inline TN ## _ref_t *V ## _extend(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_extend_offset_vector(B, len); }\
static inline TN ## _ref_t *V ## _append(NS ## builder_t *B, const TN ## _ref_t *data, size_t len)\
{ return flatcc_builder_append_offset_vector(B, data, len); }\
static inline int V ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_offset_vector(B, len); }\
static inline TN ## _ref_t *V ## _edit(NS ## builder_t *B)\
{ return (TN ## _ref_t *)flatcc_builder_offset_vector_edit(B); }\
static inline size_t V ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_offset_vector_count(B); }\
static inline TN ## _ref_t *V ## _push(NS ## builder_t *B, const TN ## _ref_t ref)\
{ return ref ? flatcc_builder_offset_vector_push(B, ref) : 0; }

#define __flatbuffers_build_offset_vector(NS, N)\
typedef NS ## ref_t N ## _vec_ref_t;\
static inline int N ## _vec_start(NS ## builder_t *B)\
{ return flatcc_builder_start_offset_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_end(NS ## builder_t *B)\
{ return flatcc_builder_end_offset_vector(B); }\
static inline N ## _vec_ref_t N ## _vec_create(NS ## builder_t *B, const N ## _ref_t *data, size_t len)\
{ return flatcc_builder_create_offset_vector(B, data, len); }\
__flatbuffers_build_offset_vector_ops(NS, N ## _vec, N, N)\
static inline N ## _vec_ref_t N ## _vec_clone(NS ## builder_t *B, N ##_vec_t vec)\
{ int _ret; N ## _ref_t _e; size_t _i, _len; __flatbuffers_memoize_begin(B, vec);\
 _len = N ## _vec_len(vec); if (flatcc_builder_start_offset_vector(B)) return 0;\
  for (_i = 0; _i < _len; ++_i) { if (!(_e = N ## _clone(B, N ## _vec_at(vec, _i)))) return 0;\
    if (!flatcc_builder_offset_vector_push(B, _e)) return 0; }\
  __flatbuffers_memoize_end(B, vec, flatcc_builder_end_offset_vector(B)); }\

#define __flatbuffers_build_string_ops(NS, N)\
static inline char *N ## _append(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_append_string(B, s, len); }\
static inline char *N ## _append_str(NS ## builder_t *B, const char *s)\
{ return flatcc_builder_append_string_str(B, s); }\
static inline char *N ## _append_strn(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_append_string_strn(B, s, len); }\
static inline size_t N ## _reserved_len(NS ## builder_t *B)\
{ return flatcc_builder_string_len(B); }\
static inline char *N ## _extend(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_extend_string(B, len); }\
static inline char *N ## _edit(NS ## builder_t *B)\
{ return flatcc_builder_string_edit(B); }\
static inline int N ## _truncate(NS ## builder_t *B, size_t len)\
{ return flatcc_builder_truncate_string(B, len); }

#define __flatbuffers_build_string(NS)\
typedef NS ## ref_t NS ## string_ref_t;\
static inline int NS ## string_start(NS ## builder_t *B)\
{ return flatcc_builder_start_string(B); }\
static inline NS ## string_ref_t NS ## string_end(NS ## builder_t *B)\
{ return flatcc_builder_end_string(B); }\
static inline NS ## ref_t NS ## string_create(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_create_string(B, s, len); }\
static inline NS ## ref_t NS ## string_create_str(NS ## builder_t *B, const char *s)\
{ return flatcc_builder_create_string_str(B, s); }\
static inline NS ## ref_t NS ## string_create_strn(NS ## builder_t *B, const char *s, size_t len)\
{ return flatcc_builder_create_string_strn(B, s, len); }\
static inline NS ## string_ref_t NS ## string_clone(NS ## builder_t *B, NS ## string_t string)\
{ __flatbuffers_memoize(B, string, flatcc_builder_create_string(B, string, NS ## string_len(string))); }\
static inline NS ## string_ref_t NS ## string_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ size_t n = NS ## string_len(string); if (index >= n) index = n; n -= index; if (len > n) len = n;\
  return flatcc_builder_create_string(B, string + index, len); }\
__flatbuffers_build_string_ops(NS, NS ## string)\
__flatbuffers_build_offset_vector(NS, NS ## string)

#define __flatbuffers_copy_from_pe(P, P2, N) (*(P) = N ## _read_from_pe(P2), (P))
#define __flatbuffers_from_pe(P, N) (*(P) = N ## _read_from_pe(P), (P))
#define __flatbuffers_copy_to_pe(P, P2, N) (N ## _write_to_pe((P), *(P2)), (P))
#define __flatbuffers_to_pe(P, N) (N ## _write_to_pe((P), *(P)), (P))
#define __flatbuffers_define_fixed_array_primitives(NS, N, T)\
static inline T *N ## _array_copy(T *p, const T *p2, size_t n)\
{ memcpy(p, p2, n * sizeof(T)); return p; }\
static inline T *N ## _array_copy_from_pe(T *p, const T *p2, size_t n)\
{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\
  for (i = 0; i < n; ++i) N ## _copy_from_pe(&p[i], &p2[i]); return p; }\
static inline T *N ## _array_copy_to_pe(T *p, const T *p2, size_t n)\
{ size_t i; if (NS ## is_native_pe()) memcpy(p, p2, n * sizeof(T)); else\
  for (i = 0; i < n; ++i) N ## _copy_to_pe(&p[i], &p2[i]); return p; }
#define __flatbuffers_define_scalar_primitives(NS, N, T)\
static inline T *N ## _from_pe(T *p) { return __ ## NS ## from_pe(p, N); }\
static inline T *N ## _to_pe(T *p) { return __ ## NS ## to_pe(p, N); }\
static inline T *N ## _copy(T *p, const T *p2) { *p = *p2; return p; }\
static inline T *N ## _copy_from_pe(T *p, const T *p2)\
{ return __ ## NS ## copy_from_pe(p, p2, N); }\
static inline T *N ## _copy_to_pe(T *p, const T *p2) \
{ return __ ## NS ## copy_to_pe(p, p2, N); }\
static inline T *N ## _assign(T *p, const T v0) { *p = v0; return p; }\
static inline T *N ## _assign_from_pe(T *p, T v0)\
{ *p = N ## _read_from_pe(&v0); return p; }\
static inline T *N ## _assign_to_pe(T *p, T v0)\
{ N ## _write_to_pe(p, v0); return p; }
#define __flatbuffers_build_scalar(NS, N, T)\
__ ## NS ## define_scalar_primitives(NS, N, T)\
__ ## NS ## define_fixed_array_primitives(NS, N, T)\
__ ## NS ## build_vector(NS, N, T, sizeof(T), sizeof(T))
/* Depends on generated copy_to/from_pe functions, and the type. */
#define __flatbuffers_define_struct_primitives(NS, N)\
static inline N ## _t *N ##_to_pe(N ## _t *p)\
{ if (!NS ## is_native_pe()) { N ## _copy_to_pe(p, p); }; return p; }\
static inline N ## _t *N ##_from_pe(N ## _t *p)\
{ if (!NS ## is_native_pe()) { N ## _copy_from_pe(p, p); }; return p; }\
static inline N ## _t *N ## _clear(N ## _t *p) { return (N ## _t *)memset(p, 0, N ## __size()); }

/* Depends on generated copy/assign_to/from_pe functions, and the type. */
#define __flatbuffers_build_struct(NS, N, S, A, FID, TFID)\
__ ## NS ## define_struct_primitives(NS, N)\
typedef NS ## ref_t N ## _ref_t;\
static inline N ## _t *N ## _start(NS ## builder_t *B)\
{ return (N ## _t *)flatcc_builder_start_struct(B, S, A); }\
static inline N ## _ref_t N ## _end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { N ## _to_pe((N ## _t *)flatcc_builder_struct_edit(B)); }\
  return flatcc_builder_end_struct(B); }\
static inline N ## _ref_t N ## _end_pe(NS ## builder_t *B)\
{ return flatcc_builder_end_struct(B); }\
static inline N ## _ref_t N ## _create(NS ## builder_t *B __ ## N ## _formal_args)\
{ N ## _t *_p = N ## _start(B); if (!_p) return 0; N ##_assign_to_pe(_p __ ## N ## _call_args);\
  return N ## _end_pe(B); }\
static inline N ## _ref_t N ## _clone(NS ## builder_t *B, N ## _struct_t p)\
{ N ## _t *_p; __flatbuffers_memoize_begin(B, p); _p = N ## _start(B); if (!_p) return 0;\
  N ## _copy(_p, p); __flatbuffers_memoize_end(B, p, N ##_end_pe(B)); }\
__flatbuffers_build_vector(NS, N, N ## _t, S, A)\
__flatbuffers_build_struct_root(NS, N, A, FID, TFID)\

#define __flatbuffers_struct_clear_field(p) memset((p), 0, sizeof(*(p)))
#define __flatbuffers_build_table(NS, N, K)\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_table(B, K); }\
static inline N ## _ref_t N ## _end(NS ## builder_t *B)\
{ FLATCC_ASSERT(flatcc_builder_check_required(B, __ ## N ## _required,\
  sizeof(__ ## N ## _required) / sizeof(__ ## N ## _required[0]) - 1));\
  return flatcc_builder_end_table(B); }\
__flatbuffers_build_offset_vector(NS, N)

#define __flatbuffers_build_table_field(ID, NS, N, TN, TT)\
static inline int N ## _add(NS ## builder_t *B, TN ## _ref_t ref)\
{ TN ## _ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ?\
  ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return TN ## _start(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _end(B)); }\
static inline TN ## _ref_t N ## _create(NS ## builder_t *B __ ## TN ##_formal_args)\
{ return N ## _add(B, TN ## _create(B __ ## TN ## _call_args)); }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _table_t p)\
{ return N ## _add(B, TN ## _clone(B, p)); }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _table_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }

#define __flatbuffers_build_union_field(ID, NS, N, TN, TT)\
static inline int N ## _add(NS ## builder_t *B, TN ## _union_ref_t uref)\
{ NS ## ref_t *_p; TN ## _union_type_t *_pt; if (uref.type == TN ## _NONE) return 0; if (uref.value == 0) return -1;\
  if (!(_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1, sizeof(*_pt), sizeof(*_pt)))) return -1;\
  *_pt = uref.type; if (!(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_p = uref.value; return 0; }\
static inline int N ## _add_type(NS ## builder_t *B, TN ## _union_type_t type)\
{ TN ## _union_type_t *_pt; if (type == TN ## _NONE) return 0; return (_pt = (TN ## _union_type_t *)flatcc_builder_table_add(B, ID - 1,\
  sizeof(*_pt), sizeof(*_pt))) ? ((*_pt = type), 0) : -1; }\
static inline int N ## _add_value(NS ## builder_t *B, TN ## _union_ref_t uref)\
{ NS ## ref_t *p; if (uref.type == TN ## _NONE) return 0; return (p = flatcc_builder_table_add_offset(B, ID)) ?\
  ((*p = uref.value), 0) : -1; }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _union_t p)\
{ return N ## _add(B, TN ## _clone(B, p)); }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _union_t _p = N ## _union(t); return _p.type ? N ## _clone(B, _p) : 0; }

/* M is the union value name and T is its type, i.e. the qualified name. */
#define __flatbuffers_build_union_table_value_field(NS, N, NU, M, T)\
static inline int N ## _ ## M ## _add(NS ## builder_t *B, T ## _ref_t ref)\
{ return N ## _add(B, NU ## _as_ ## M (ref)); }\
static inline int N ## _ ## M ## _start(NS ## builder_t *B)\
{ return T ## _start(B); }\
static inline int N ## _ ## M ## _end(NS ## builder_t *B)\
{ T ## _ref_t ref = T ## _end(B);\
  return ref ? N ## _ ## M ## _add(B, ref) : -1; }\
static inline int N ## _ ## M ## _create(NS ## builder_t *B __ ## T ##_formal_args)\
{ T ## _ref_t ref = T ## _create(B __ ## T ## _call_args);\
  return ref ? N ## _add(B, NU ## _as_ ## M(ref)) : -1; }\
static inline int N ## _ ## M ## _clone(NS ## builder_t *B, T ## _table_t t)\
{ T ## _ref_t ref = T ## _clone(B, t);\
  return ref ? N ## _add(B, NU ## _as_ ## M(ref)) : -1; }

/* M is the union value name and T is its type, i.e. the qualified name. */
#define __flatbuffers_build_union_struct_value_field(NS, N, NU, M, T)\
static inline int N ## _ ## M ## _add(NS ## builder_t *B, T ## _ref_t ref)\
{ return N ## _add(B, NU ## _as_ ## M (ref)); }\
static inline T ## _t *N ## _ ## M ## _start(NS ## builder_t *B)\
{ return T ## _start(B); }\
static inline int N ## _ ## M ## _end(NS ## builder_t *B)\
{ T ## _ref_t ref = T ## _end(B);\
  return ref ? N ## _ ## M ## _add(B, ref) : -1; }\
static inline int N ## _ ## M ## _create(NS ## builder_t *B __ ## T ##_formal_args)\
{ T ## _ref_t ref = T ## _create(B __ ## T ## _call_args);\
  return ref ? N ## _add(B, NU ## _as_ ## M(ref)) : -1; }\
static inline int N ## _ ## M ## _end_pe(NS ## builder_t *B)\
{ T ## _ref_t ref = T ## _end_pe(B);\
  return ref ? N ## _add(B, NU ## _as_ ## M(ref)) : -1; }\
static inline int N ## _ ## M ## _clone(NS ## builder_t *B, T ## _struct_t p)\
{ T ## _ref_t ref = T ## _clone(B, p);\
  return ref ? N ## _add(B, NU ## _as_ ## M(ref)) : -1; }
#define __flatbuffers_build_union_string_value_field(NS, N, NU, M)\
static inline int N ## _ ## M ## _add(NS ## builder_t *B, NS ## string_ref_t ref)\
{ return N ## _add(B, NU ## _as_ ## M (ref)); }\
__flatbuffers_build_string_field_ops(NS, N ## _ ## M)

/* NS: common namespace, ID: table field id (not offset), TN: name of type T, TT: name of table type
 * S: sizeof of scalar type, A: alignment of type T, default value V of type T. */
#define __flatbuffers_build_scalar_field(ID, NS, N, TN, T, S, A, V, TT)\
static inline int N ## _add(NS ## builder_t *B, const T v)\
{ T *_p; if (v == V) return 0; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\
  TN ## _assign_to_pe(_p, v); return 0; }\
static inline int N ## _force_add(NS ## builder_t *B, const T v)\
{ T *_p; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\
  TN ## _assign_to_pe(_p, v); return 0; }\
/* Clone does not skip default values and expects pe endian content. */\
static inline int N ## _clone(NS ## builder_t *B, const T *p)\
{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\
/* Transferring a missing field is a nop success with 0 as result. */\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }

/* NS: common namespace, ID: table field id (not offset), TN: name of type T, TT: name of table type
 * S: sizeof of scalar type, A: alignment of type T. */
#define __flatbuffers_build_scalar_optional_field(ID, NS, N, TN, T, S, A, TT)\
static inline int N ## _add(NS ## builder_t *B, const T v)\
{ T *_p; if (!(_p = (T *)flatcc_builder_table_add(B, ID, S, A))) return -1;\
  TN ## _assign_to_pe(_p, v); return 0; }\
/* Clone does not skip default values and expects pe endian content. */\
static inline int N ## _clone(NS ## builder_t *B, const T *p)\
{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\
/* Transferring a missing field is a nop success with 0 as result. */\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ const T *_p = N ## _get_ptr(t); return _p ? N ## _clone(B, _p) : 0; }

#define __flatbuffers_build_struct_field(ID, NS, N, TN, S, A, TT)\
static inline TN ## _t *N ## _start(NS ## builder_t *B)\
{ return (TN ## _t *)flatcc_builder_table_add(B, ID, S, A); }\
static inline int N ## _end(NS ## builder_t *B)\
{ if (!NS ## is_native_pe()) { TN ## _to_pe((TN ## _t *)flatcc_builder_table_edit(B, S)); } return 0; }\
static inline int N ## _end_pe(NS ## builder_t *B) { return 0; }\
static inline int N ## _create(NS ## builder_t *B __ ## TN ## _formal_args)\
{ TN ## _t *_p = N ## _start(B); if (!_p) return -1; TN ##_assign_to_pe(_p __ ## TN ## _call_args);\
  return 0; }\
static inline int N ## _add(NS ## builder_t *B, const TN ## _t *p)\
{ TN ## _t *_p = N ## _start(B); if (!_p) return -1; TN ##_copy_to_pe(_p, p); return 0; }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _struct_t p)\
{ return 0 == flatcc_builder_table_add_copy(B, ID, p, S, A) ? -1 : 0; }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _struct_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }

#define __flatbuffers_build_vector_field(ID, NS, N, TN, T, TT)\
static inline int N ## _add(NS ## builder_t *B, TN ## _vec_ref_t ref)\
{ TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return TN ## _vec_start(B); }\
static inline int N ## _end_pe(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _vec_end_pe(B)); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, TN ## _vec_end(B)); }\
static inline int N ## _create_pe(NS ## builder_t *B, const T *data, size_t len)\
{ return N ## _add(B, TN ## _vec_create_pe(B, data, len)); }\
static inline int N ## _create(NS ## builder_t *B, const T *data, size_t len)\
{ return N ## _add(B, TN ## _vec_create(B, data, len)); }\
static inline int N ## _slice(NS ## builder_t *B, TN ## _vec_t vec, size_t index, size_t len)\
{ return N ## _add(B, TN ## _vec_slice(B, vec, index, len)); }\
static inline int N ## _clone(NS ## builder_t *B, TN ## _vec_t vec)\
{ return N ## _add(B, TN ## _vec_clone(B, vec)); }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _vec_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }\
__flatbuffers_build_vector_ops(NS, N, N, TN, T)\

#define __flatbuffers_build_offset_vector_field(ID, NS, N, TN, TT)\
static inline int N ## _add(NS ## builder_t *B, TN ## _vec_ref_t ref)\
{ TN ## _vec_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_offset_vector(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, flatcc_builder_end_offset_vector(B)); }\
static inline int N ## _create(NS ## builder_t *B, const TN ## _ref_t *data, size_t len)\
{ return N ## _add(B, flatcc_builder_create_offset_vector(B, data, len)); }\
__flatbuffers_build_offset_vector_ops(NS, N, N, TN)\
static inline int N ## _clone(NS ## builder_t *B, TN ## _vec_t vec)\
{ return N ## _add(B, TN ## _vec_clone(B, vec)); }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _vec_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }

/* depends on N ## _add which differs for union member fields and ordinary fields */\
#define __flatbuffers_build_string_field_ops(NS, N)\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_string(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, flatcc_builder_end_string(B)); }\
static inline int N ## _create(NS ## builder_t *B, const char *s, size_t len)\
{ return N ## _add(B, flatcc_builder_create_string(B, s, len)); }\
static inline int N ## _create_str(NS ## builder_t *B, const char *s)\
{ return N ## _add(B, flatcc_builder_create_string_str(B, s)); }\
static inline int N ## _create_strn(NS ## builder_t *B, const char *s, size_t max_len)\
{ return N ## _add(B, flatcc_builder_create_string_strn(B, s, max_len)); }\
static inline int N ## _clone(NS ## builder_t *B, NS ## string_t string)\
{ return N ## _add(B, NS ## string_clone(B, string)); }\
static inline int N ## _slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ return N ## _add(B, NS ## string_slice(B, string, index, len)); }\
__flatbuffers_build_string_ops(NS, N)

#define __flatbuffers_build_string_field(ID, NS, N, TT)\
static inline int N ## _add(NS ## builder_t *B, NS ## string_ref_t ref)\
{ NS ## string_ref_t *_p; return (ref && (_p = flatcc_builder_table_add_offset(B, ID))) ? ((*_p = ref), 0) : -1; }\
__flatbuffers_build_string_field_ops(NS, N)\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ NS ## string_t _p = N ## _get(t); return _p ? N ## _clone(B, _p) : 0; }

#define __flatbuffers_build_table_vector_field(ID, NS, N, TN, TT)\
__flatbuffers_build_offset_vector_field(ID, NS, N, TN, TT)\
__flatbuffers_build_table_vector_ops(NS, N, TN)

#define __flatbuffers_build_union_vector_field(ID, NS, N, TN, TT)\
static inline int N ## _add(NS ## builder_t *B, TN ## _union_vec_ref_t uvref)\
{ NS ## vec_ref_t *_p; if (!uvref.type || !uvref.value) return uvref.type == uvref.value ? 0 : -1;\
  if (!(_p = flatcc_builder_table_add_offset(B, ID - 1))) return -1; *_p = uvref.type;\
  if (!(_p = flatcc_builder_table_add_offset(B, ID))) return -1; *_p = uvref.value; return 0; }\
static inline int N ## _start(NS ## builder_t *B)\
{ return flatcc_builder_start_union_vector(B); }\
static inline int N ## _end(NS ## builder_t *B)\
{ return N ## _add(B, flatcc_builder_end_union_vector(B)); }\
static inline int N ## _create(NS ## builder_t *B, const TN ## _union_ref_t *data, size_t len)\
{ return N ## _add(B, flatcc_builder_create_union_vector(B, data, len)); }\
__flatbuffers_build_union_vector_ops(NS, N, N, TN)\
static inline int N ## _clone(NS ## builder_t *B, TN ## _union_vec_t vec)\
{ return N ## _add(B, TN ## _vec_clone(B, vec)); }\
static inline int N ## _pick(NS ## builder_t *B, TT ## _table_t t)\
{ TN ## _union_vec_t _p = N ## _union(t); return _p.type ? N ## _clone(B, _p) : 0; }

#define __flatbuffers_build_union_table_vector_value_field(NS, N, NU, M, T)\
static inline int N ## _ ## M ## _push_start(NS ## builder_t *B)\
{ return T ## _start(B); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_end(NS ## builder_t *B)\
{ return NU ## _vec_push(B, NU ## _as_ ## M (T ## _end(B))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push(NS ## builder_t *B, T ## _ref_t ref)\
{ return NU ## _vec_push(B, NU ## _as_ ## M (ref)); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_create(NS ## builder_t *B __ ## T ##_formal_args)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(T ## _create(B __ ## T ## _call_args))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_clone(NS ## builder_t *B, T ## _table_t t)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(T ## _clone(B, t))); }

#define __flatbuffers_build_union_struct_vector_value_field(NS, N, NU, M, T)\
static inline T ## _t *N ## _ ## M ## _push_start(NS ## builder_t *B)\
{ return T ## _start(B); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_end(NS ## builder_t *B)\
{ return NU ## _vec_push(B, NU ## _as_ ## M (T ## _end(B))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push(NS ## builder_t *B, T ## _ref_t ref)\
{ return NU ## _vec_push(B, NU ## _as_ ## M (ref)); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_create(NS ## builder_t *B __ ## T ##_formal_args)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(T ## _create(B __ ## T ## _call_args))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_clone(NS ## builder_t *B, T ## _struct_t p)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(T ## _clone(B, p))); }

#define __flatbuffers_build_union_string_vector_value_field(NS, N, NU, M)\
static inline NU ## _union_ref_t *N ## _ ## M ## _push(NS ## builder_t *B, NS ## string_ref_t ref)\
{ return NU ## _vec_push(B, NU ## _as_ ## M (ref)); }\
static inline int N ## _ ## M ## _push_start(NS ## builder_t *B)\
{ return NS ## string_start(B); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_end(NS ## builder_t *B)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_end(B))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_create(NS ## builder_t *B, const char *s, size_t len)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_create(B, s, len))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_create_str(NS ## builder_t *B, const char *s)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_create_str(B, s))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_create_strn(NS ## builder_t *B, const char *s, size_t max_len)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_create_strn(B, s, max_len))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_clone(NS ## builder_t *B, NS ## string_t string)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_clone(B, string))); }\
static inline NU ## _union_ref_t *N ## _ ## M ## _push_slice(NS ## builder_t *B, NS ## string_t string, size_t index, size_t len)\
{ return NU ## _vec_push(B, NU ## _as_ ## M(NS ## string_slice(B, string, index, len))); }

#define __flatbuffers_build_string_vector_field(ID, NS, N, TT)\
__flatbuffers_build_offset_vector_field(ID, NS, N, NS ## string, TT)\
__flatbuffers_build_string_vector_ops(NS, N)

#define __flatbuffers_char_formal_args , char v0
#define __flatbuffers_char_call_args , v0
#define __flatbuffers_uint8_formal_args , uint8_t v0
#define __flatbuffers_uint8_call_args , v0
#define __flatbuffers_int8_formal_args , int8_t v0
#define __flatbuffers_int8_call_args , v0
#define __flatbuffers_bool_formal_args , flatbuffers_bool_t v0
#define __flatbuffers_bool_call_args , v0
#define __flatbuffers_uint16_formal_args , uint16_t v0
#define __flatbuffers_uint16_call_args , v0
#define __flatbuffers_uint32_formal_args , uint32_t v0
#define __flatbuffers_uint32_call_args , v0
#define __flatbuffers_uint64_formal_args , uint64_t v0
#define __flatbuffers_uint64_call_args , v0
#define __flatbuffers_int16_formal_args , int16_t v0
#define __flatbuffers_int16_call_args , v0
#define __flatbuffers_int32_formal_args , int32_t v0
#define __flatbuffers_int32_call_args , v0
#define __flatbuffers_int64_formal_args , int64_t v0
#define __flatbuffers_int64_call_args , v0
#define __flatbuffers_float_formal_args , float v0
#define __flatbuffers_float_call_args , v0
#define __flatbuffers_double_formal_args , double v0
#define __flatbuffers_double_call_args , v0

__flatbuffers_build_scalar(flatbuffers_, flatbuffers_char, char)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint8, uint8_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int8, int8_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_bool, flatbuffers_bool_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint16, uint16_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint32, uint32_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_uint64, uint64_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int16, int16_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int32, int32_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_int64, int64_t)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_float, float)
__flatbuffers_build_scalar(flatbuffers_, flatbuffers_double, double)

__flatbuffers_build_string(flatbuffers_)

__flatbuffers_build_buffer(flatbuffers_)
#include "flatcc/flatcc_epilogue.h"
#endif /* FLATBUFFERS_COMMON_BUILDER_H */
#ifndef XYZZY_READER_H
#define XYZZY_READER_H

/* Generated by flatcc 0.6.1-dev FlatBuffers schema compiler for C by dvide.com */

#ifndef FLATBUFFERS_COMMON_READER_H
#include "flatbuffers_common_reader.h"
#endif
#include "flatcc/flatcc_flatbuffers.h"
#ifndef __alignas_is_defined
#include <stdalign.h>
#endif
#include "flatcc/flatcc_prologue.h"
#undef flatbuffers_identifier
#define flatbuffers_identifier "fbuz"
#undef flatbuffers_extension
#define flatbuffers_extension ".cgen_test"

typedef struct the_shade the_shade_t;
typedef const the_shade_t *the_shade_struct_t;
typedef the_shade_t *the_shade_mutable_struct_t;
typedef const the_shade_t *the_shade_vec_t;
typedef the_shade_t *the_shade_mutable_vec_t;
typedef struct the_notify the_notify_t;
typedef const the_notify_t *the_notify_struct_t;
typedef the_notify_t *the_notify_mutable_struct_t;
typedef const the_notify_t *the_notify_vec_t;
typedef the_notify_t *the_notify_mutable_vec_t;
typedef struct the_s1 the_s1_t;
typedef const the_s1_t *the_s1_struct_t;
typedef the_s1_t *the_s1_mutable_struct_t;
typedef const the_s1_t *the_s1_vec_t;
typedef the_s1_t *the_s1_mutable_vec_t;
typedef struct little_whale_c3 little_whale_c3_t;
typedef const little_whale_c3_t *little_whale_c3_struct_t;
typedef little_whale_c3_t *little_whale_c3_mutable_struct_t;
typedef const little_whale_c3_t *little_whale_c3_vec_t;
typedef little_whale_c3_t *little_whale_c3_mutable_vec_t;
typedef struct little_whale_c2 little_whale_c2_t;
typedef const little_whale_c2_t *little_whale_c2_struct_t;
typedef little_whale_c2_t *little_whale_c2_mutable_struct_t;
typedef const little_whale_c2_t *little_whale_c2_vec_t;
typedef little_whale_c2_t *little_whale_c2_mutable_vec_t;
typedef struct the_c1 the_c1_t;
typedef const the_c1_t *the_c1_struct_t;
typedef the_c1_t *the_c1_mutable_struct_t;
typedef const the_c1_t *the_c1_vec_t;
typedef the_c1_t *the_c1_mutable_vec_t;

typedef const struct point_table *point_table_t;
typedef struct point_table *point_mutable_table_t;
typedef const flatbuffers_uoffset_t *point_vec_t;
typedef flatbuffers_uoffset_t *point_mutable_vec_t;
typedef const struct mystic_island_table *mystic_island_table_t;
typedef struct mystic_island_table *mystic_island_mutable_table_t;
typedef const flatbuffers_uoffset_t *mystic_island_vec_t;
typedef flatbuffers_uoffset_t *mystic_island_mutable_vec_t;
typedef const struct mystic_point_table *mystic_point_table_t;
typedef struct mystic_point_table *mystic_point_mutable_table_t;
typedef const flatbuffers_uoffset_t *mystic_point_vec_t;
typedef flatbuffers_uoffset_t *mystic_point_mutable_vec_t;
typedef const struct the_foo_table *the_foo_table_t;
typedef struct the_foo_table *the_foo_mutable_table_t;
typedef const flatbuffers_uoffset_t *the_foo_vec_t;
typedef flatbuffers_uoffset_t *the_foo_mutable_vec_t;
typedef const struct the_goo_table *the_goo_table_t;
typedef struct the_goo_table *the_goo_mutable_table_t;
typedef const flatbuffers_uoffset_t *the_goo_vec_t;
typedef flatbuffers_uoffset_t *the_goo_mutable_vec_t;
typedef const struct little_whale_hop_table *little_whale_hop_table_t;
typedef struct little_whale_hop_table *little_whale_hop_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_hop_vec_t;
typedef flatbuffers_uoffset_t *little_whale_hop_mutable_vec_t;
typedef const struct little_whale_TestOrder_table *little_whale_TestOrder_table_t;
typedef struct little_whale_TestOrder_table *little_whale_TestOrder_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_TestOrder_vec_t;
typedef flatbuffers_uoffset_t *little_whale_TestOrder_mutable_vec_t;
typedef const struct little_whale_TestOrder2_table *little_whale_TestOrder2_table_t;
typedef struct little_whale_TestOrder2_table *little_whale_TestOrder2_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_TestOrder2_vec_t;
typedef flatbuffers_uoffset_t *little_whale_TestOrder2_mutable_vec_t;
typedef const struct little_whale_StoreResponse_table *little_whale_StoreResponse_table_t;
typedef struct little_whale_StoreResponse_table *little_whale_StoreResponse_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_StoreResponse_vec_t;
typedef flatbuffers_uoffset_t *little_whale_StoreResponse_mutable_vec_t;
typedef const struct little_whale_Monster_table *little_whale_Monster_table_t;
typedef struct little_whale_Monster_table *little_whale_Monster_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_Monster_vec_t;
typedef flatbuffers_uoffset_t *little_whale_Monster_mutable_vec_t;
typedef const struct little_whale_MonsterId_table *little_whale_MonsterId_table_t;
typedef struct little_whale_MonsterId_table *little_whale_MonsterId_mutable_table_t;
typedef const flatbuffers_uoffset_t *little_whale_MonsterId_vec_t;
typedef flatbuffers_uoffset_t *little_whale_MonsterId_mutable_vec_t;
#ifndef point_file_identifier
#define point_file_identifier flatbuffers_identifier
#endif
/* deprecated, use point_file_identifier */
#ifndef point_identifier
#define point_identifier flatbuffers_identifier
#endif
#define point_type_hash ((flatbuffers_thash_t)0x18ae6c91)
#define point_type_identifier "\x91\x6c\xae\x18"
#ifndef mystic_island_file_identifier
#define mystic_island_file_identifier flatbuffers_identifier
#endif
/* deprecated, use mystic_island_file_identifier */
#ifndef mystic_island_identifier
#define mystic_island_identifier flatbuffers_identifier
#endif
#define mystic_island_type_hash ((flatbuffers_thash_t)0x3378a4fb)
#define mystic_island_type_identifier "\xfb\xa4\x78\x33"
#ifndef mystic_point_file_identifier
#define mystic_point_file_identifier flatbuffers_identifier
#endif
/* deprecated, use mystic_point_file_identifier */
#ifndef mystic_point_identifier
#define mystic_point_identifier flatbuffers_identifier
#endif
#define mystic_point_type_hash ((flatbuffers_thash_t)0xb38a8650)
#define mystic_point_type_identifier "\x50\x86\x8a\xb3"
#ifndef the_shade_file_identifier
#define the_shade_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_shade_file_identifier */
#ifndef the_shade_identifier
#define the_shade_identifier flatbuffers_identifier
#endif
#define the_shade_type_hash ((flatbuffers_thash_t)0x16c059b7)
#define the_shade_type_identifier "\xb7\x59\xc0\x16"
#ifndef the_foo_file_identifier
#define the_foo_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_foo_file_identifier */
#ifndef the_foo_identifier
#define the_foo_identifier flatbuffers_identifier
#endif
#define the_foo_type_hash ((flatbuffers_thash_t)0x5115a06)
#define the_foo_type_identifier "\x06\x5a\x11\x05"
#ifndef the_notify_file_identifier
#define the_notify_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_notify_file_identifier */
#ifndef the_notify_identifier
#define the_notify_identifier flatbuffers_identifier
#endif
#define the_notify_type_hash ((flatbuffers_thash_t)0x7b9a4e83)
#define the_notify_type_identifier "\x83\x4e\x9a\x7b"
#ifndef the_goo_file_identifier
#define the_goo_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_goo_file_identifier */
#ifndef the_goo_identifier
#define the_goo_identifier flatbuffers_identifier
#endif
#define the_goo_type_hash ((flatbuffers_thash_t)0x73c5e371)
#define the_goo_type_identifier "\x71\xe3\xc5\x73"
#ifndef the_s1_file_identifier
#define the_s1_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_s1_file_identifier */
#ifndef the_s1_identifier
#define the_s1_identifier flatbuffers_identifier
#endif
#define the_s1_type_hash ((flatbuffers_thash_t)0x84f86e6a)
#define the_s1_type_identifier "\x6a\x6e\xf8\x84"
#ifndef the_c1_file_identifier
#define the_c1_file_identifier flatbuffers_identifier
#endif
/* deprecated, use the_c1_file_identifier */
#ifndef the_c1_identifier
#define the_c1_identifier flatbuffers_identifier
#endif
#define the_c1_type_hash ((flatbuffers_thash_t)0x520475a)
#define the_c1_type_identifier "\x5a\x47\x20\x05"
#ifndef little_whale_c2_file_identifier
#define little_whale_c2_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_c2_file_identifier */
#ifndef little_whale_c2_identifier
#define little_whale_c2_identifier flatbuffers_identifier
#endif
#define little_whale_c2_type_hash ((flatbuffers_thash_t)0xbdaa6a1)
#define little_whale_c2_type_identifier "\xa1\xa6\xda\x0b"
#ifndef little_whale_c3_file_identifier
#define little_whale_c3_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_c3_file_identifier */
#ifndef little_whale_c3_identifier
#define little_whale_c3_identifier flatbuffers_identifier
#endif
#define little_whale_c3_type_hash ((flatbuffers_thash_t)0xadaa50e)
#define little_whale_c3_type_identifier "\x0e\xa5\xda\x0a"
#ifndef little_whale_hop_file_identifier
#define little_whale_hop_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_hop_file_identifier */
#ifndef little_whale_hop_identifier
#define little_whale_hop_identifier flatbuffers_identifier
#endif
#define little_whale_hop_type_hash ((flatbuffers_thash_t)0xa286a0ef)
#define little_whale_hop_type_identifier "\xef\xa0\x86\xa2"
#ifndef little_whale_TestOrder_file_identifier
#define little_whale_TestOrder_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_TestOrder_file_identifier */
#ifndef little_whale_TestOrder_identifier
#define little_whale_TestOrder_identifier flatbuffers_identifier
#endif
#define little_whale_TestOrder_type_hash ((flatbuffers_thash_t)0x603d6f0c)
#define little_whale_TestOrder_type_identifier "\x0c\x6f\x3d\x60"
#ifndef little_whale_TestOrder2_file_identifier
#define little_whale_TestOrder2_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_TestOrder2_file_identifier */
#ifndef little_whale_TestOrder2_identifier
#define little_whale_TestOrder2_identifier flatbuffers_identifier
#endif
#define little_whale_TestOrder2_type_hash ((flatbuffers_thash_t)0xbeb61e9a)
#define little_whale_TestOrder2_type_identifier "\x9a\x1e\xb6\xbe"
#ifndef little_whale_StoreResponse_file_identifier
#define little_whale_StoreResponse_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_StoreResponse_file_identifier */
#ifndef little_whale_StoreResponse_identifier
#define little_whale_StoreResponse_identifier flatbuffers_identifier
#endif
#define little_whale_StoreResponse_type_hash ((flatbuffers_thash_t)0xd3a405da)
#define little_whale_StoreResponse_type_identifier "\xda\x05\xa4\xd3"
#ifndef little_whale_Monster_file_identifier
#define little_whale_Monster_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_Monster_file_identifier */
#ifndef little_whale_Monster_identifier
#define little_whale_Monster_identifier flatbuffers_identifier
#endif
#define little_whale_Monster_type_hash ((flatbuffers_thash_t)0x6c7bf0a6)
#define little_whale_Monster_type_identifier "\xa6\xf0\x7b\x6c"
#ifndef little_whale_MonsterId_file_identifier
#define little_whale_MonsterId_file_identifier flatbuffers_identifier
#endif
/* deprecated, use little_whale_MonsterId_file_identifier */
#ifndef little_whale_MonsterId_identifier
#define little_whale_MonsterId_identifier flatbuffers_identifier
#endif
#define little_whale_MonsterId_type_hash ((flatbuffers_thash_t)0x785e41b)
#define little_whale_MonsterId_type_identifier "\x1b\xe4\x85\x07"

typedef int32_t mystic_agent_enum_t;
__flatbuffers_define_integer_type(mystic_agent, mystic_agent_enum_t, 32)
#define mystic_agent_lot ((mystic_agent_enum_t)INT32_C(0))
#define mystic_agent_pirate ((mystic_agent_enum_t)INT32_C(1))
#define mystic_agent_vessel ((mystic_agent_enum_t)INT32_C(2))
#define mystic_agent_navy ((mystic_agent_enum_t)INT32_C(3))
#define mystic_agent_parrot ((mystic_agent_enum_t)INT32_C(4))

static inline const char *mystic_agent_name(mystic_agent_enum_t value)
{
    switch (value) {
    case mystic_agent_lot: return "lot";
    case mystic_agent_pirate: return "pirate";
    case mystic_agent_vessel: return "vessel";
    case mystic_agent_navy: return "navy";
    case mystic_agent_parrot: return "parrot";
    default: return "";
    }
}

static inline int mystic_agent_is_known_value(mystic_agent_enum_t value)
{
    switch (value) {
    case mystic_agent_lot: return 1;
    case mystic_agent_pirate: return 1;
    case mystic_agent_vessel: return 1;
    case mystic_agent_navy: return 1;
    case mystic_agent_parrot: return 1;
    default: return 0;
    }
}

typedef int16_t the_e1_enum_t;
__flatbuffers_define_integer_type(the_e1, the_e1_enum_t, 16)
#define the_e1_z ((the_e1_enum_t)INT16_C(-2))
#define the_e1_one ((the_e1_enum_t)INT16_C(-1))
#define the_e1_two ((the_e1_enum_t)INT16_C(0))
#define the_e1_three ((the_e1_enum_t)INT16_C(3))

static inline const char *the_e1_name(the_e1_enum_t value)
{
    switch (value) {
    case the_e1_z: return "z";
    case the_e1_one: return "one";
    case the_e1_two: return "two";
    case the_e1_three: return "three";
    default: return "";
    }
}

static inline int the_e1_is_known_value(the_e1_enum_t value)
{
    switch (value) {
    case the_e1_z: return 1;
    case the_e1_one: return 1;
    case the_e1_two: return 1;
    case the_e1_three: return 1;
    default: return 0;
    }
}

typedef int16_t the_flags_enum_t;
__flatbuffers_define_integer_type(the_flags, the_flags_enum_t, 16)
#define the_flags_f1 ((the_flags_enum_t)INT16_C(2))
#define the_flags_f2 ((the_flags_enum_t)INT16_C(8192))
#define the_flags_f3 ((the_flags_enum_t)INT16_C(16384))

static inline const char *the_flags_name(the_flags_enum_t value)
{
    switch (value) {
    case the_flags_f1: return "f1";
    case the_flags_f2: return "f2";
    case the_flags_f3: return "f3";
    default: return "";
    }
}

static inline int the_flags_is_known_value(the_flags_enum_t value)
{
    switch (value) {
    case the_flags_f1: return 1;
    case the_flags_f2: return 1;
    case the_flags_f3: return 1;
    default: return 0;
    }
}

typedef uint32_t the_flags2_enum_t;
__flatbuffers_define_integer_type(the_flags2, the_flags2_enum_t, 32)
#define the_flags2_zulu ((the_flags2_enum_t)UINT32_C(1))
#define the_flags2_alpha ((the_flags2_enum_t)UINT32_C(2))
#define the_flags2_bravo ((the_flags2_enum_t)UINT32_C(4))
#define the_flags2_charlie ((the_flags2_enum_t)UINT32_C(8))
#define the_flags2_delta ((the_flags2_enum_t)UINT32_C(16))
#define the_flags2_echo ((the_flags2_enum_t)UINT32_C(32))
#define the_flags2_foxtrot ((the_flags2_enum_t)UINT32_C(64))

static inline const char *the_flags2_name(the_flags2_enum_t value)
{
    switch (value) {
    case the_flags2_zulu: return "zulu";
    case the_flags2_alpha: return "alpha";
    case the_flags2_bravo: return "bravo";
    case the_flags2_charlie: return "charlie";
    case the_flags2_delta: return "delta";
    case the_flags2_echo: return "echo";
    case the_flags2_foxtrot: return "foxtrot";
    default: return "";
    }
}

static inline int the_flags2_is_known_value(the_flags2_enum_t value)
{
    switch (value) {
    case the_flags2_zulu: return 1;
    case the_flags2_alpha: return 1;
    case the_flags2_bravo: return 1;
    case the_flags2_charlie: return 1;
    case the_flags2_delta: return 1;
    case the_flags2_echo: return 1;
    case the_flags2_foxtrot: return 1;
    default: return 0;
    }
}

/**  A boolean enum - all enums must be type. */
typedef flatbuffers_bool_t the_confirm_enum_t;
__flatbuffers_define_integer_type(the_confirm, the_confirm_enum_t, 8)
#define the_confirm_no ((the_confirm_enum_t)UINT8_C(0))
#define the_confirm_yes ((the_confirm_enum_t)UINT8_C(1))

static inline const char *the_confirm_name(the_confirm_enum_t value)
{
    switch (value) {
    case the_confirm_no: return "no";
    case the_confirm_yes: return "yes";
    default: return "";
    }
}

static inline int the_confirm_is_known_value(the_confirm_enum_t value)
{
    switch (value) {
    case the_confirm_no: return 1;
    case the_confirm_yes: return 1;
    default: return 0;
    }
}


/**  shade is for CG applications */
struct the_shade {
    alignas(2) int8_t x;
    alignas(1) int8_t y;
    alignas(1) int8_t z;
    /**  alpha is unsigned! */
    alignas(1) uint8_t alpha;
};
static_assert(sizeof(the_shade_t) == 4, "struct size mismatch");

static inline const the_shade_t *the_shade__const_ptr_add(const the_shade_t *p, size_t i) { return p + i; }
static inline the_shade_t *the_shade__ptr_add(the_shade_t *p, size_t i) { return p + i; }
static inline the_shade_struct_t the_shade_vec_at(the_shade_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t the_shade__size(void) { return 4; }
static inline size_t the_shade_vec_len(the_shade_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(the_shade)

__flatbuffers_define_struct_scalar_field(the_shade, x, flatbuffers_int8, int8_t)
__flatbuffers_define_struct_scalar_field(the_shade, y, flatbuffers_int8, int8_t)
__flatbuffers_define_struct_scalar_field(the_shade, z, flatbuffers_int8, int8_t)
__flatbuffers_define_struct_scalar_field(the_shade, alpha, flatbuffers_uint8, uint8_t)
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(the_shade, alpha, uint8_t)
__flatbuffers_define_struct_sort_by_scalar_field(the_shade, alpha, uint8_t, the_shade_t)
__flatbuffers_define_default_find_by_scalar_field(the_shade, alpha, uint8_t)
__flatbuffers_define_default_scan_by_scalar_field(the_shade, alpha, uint8_t)
#define the_shade_vec_sort the_shade_vec_sort_by_alpha

struct the_notify {
    alignas(2) the_confirm_enum_t primary_recipient;
    alignas(1) the_confirm_enum_t secondary_recipient;
    alignas(2) the_flags_enum_t flags;
};
static_assert(sizeof(the_notify_t) == 4, "struct size mismatch");

static inline const the_notify_t *the_notify__const_ptr_add(const the_notify_t *p, size_t i) { return p + i; }
static inline the_notify_t *the_notify__ptr_add(the_notify_t *p, size_t i) { return p + i; }
static inline the_notify_struct_t the_notify_vec_at(the_notify_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t the_notify__size(void) { return 4; }
static inline size_t the_notify_vec_len(the_notify_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(the_notify)

__flatbuffers_define_struct_scalar_field(the_notify, primary_recipient, the_confirm, the_confirm_enum_t)
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(the_notify, primary_recipient, the_confirm_enum_t)
__flatbuffers_define_struct_sort_by_scalar_field(the_notify, primary_recipient, the_confirm_enum_t, the_notify_t)
__flatbuffers_define_default_find_by_scalar_field(the_notify, primary_recipient, the_confirm_enum_t)
__flatbuffers_define_default_scan_by_scalar_field(the_notify, primary_recipient, the_confirm_enum_t)
#define the_notify_vec_sort the_notify_vec_sort_by_primary_recipient
__flatbuffers_define_struct_scalar_field(the_notify, secondary_recipient, the_confirm, the_confirm_enum_t)
__flatbuffers_define_struct_scalar_field(the_notify, flags, the_flags, the_flags_enum_t)

struct the_s1 {
    alignas(4) int32_t index;
};
static_assert(sizeof(the_s1_t) == 4, "struct size mismatch");

static inline const the_s1_t *the_s1__const_ptr_add(const the_s1_t *p, size_t i) { return p + i; }
static inline the_s1_t *the_s1__ptr_add(the_s1_t *p, size_t i) { return p + i; }
static inline the_s1_struct_t the_s1_vec_at(the_s1_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t the_s1__size(void) { return 4; }
static inline size_t the_s1_vec_len(the_s1_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(the_s1)

__flatbuffers_define_struct_scalar_field(the_s1, index, flatbuffers_int32, int32_t)
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(the_s1, index, int32_t)
__flatbuffers_define_struct_sort_by_scalar_field(the_s1, index, int32_t, the_s1_t)
__flatbuffers_define_default_find_by_scalar_field(the_s1, index, int32_t)
__flatbuffers_define_default_scan_by_scalar_field(the_s1, index, int32_t)
#define the_s1_vec_sort the_s1_vec_sort_by_index

struct little_whale_c3 {
    alignas(4) the_s1_t z;
};
static_assert(sizeof(little_whale_c3_t) == 4, "struct size mismatch");

static inline const little_whale_c3_t *little_whale_c3__const_ptr_add(const little_whale_c3_t *p, size_t i) { return p + i; }
static inline little_whale_c3_t *little_whale_c3__ptr_add(little_whale_c3_t *p, size_t i) { return p + i; }
static inline little_whale_c3_struct_t little_whale_c3_vec_at(little_whale_c3_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t little_whale_c3__size(void) { return 4; }
static inline size_t little_whale_c3_vec_len(little_whale_c3_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(little_whale_c3)

__flatbuffers_define_struct_struct_field(little_whale_c3, z, the_s1_struct_t)

struct little_whale_c2 {
    alignas(4) little_whale_c3_t y;
};
static_assert(sizeof(little_whale_c2_t) == 4, "struct size mismatch");

static inline const little_whale_c2_t *little_whale_c2__const_ptr_add(const little_whale_c2_t *p, size_t i) { return p + i; }
static inline little_whale_c2_t *little_whale_c2__ptr_add(little_whale_c2_t *p, size_t i) { return p + i; }
static inline little_whale_c2_struct_t little_whale_c2_vec_at(little_whale_c2_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t little_whale_c2__size(void) { return 4; }
static inline size_t little_whale_c2_vec_len(little_whale_c2_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(little_whale_c2)

__flatbuffers_define_struct_struct_field(little_whale_c2, y, little_whale_c3_struct_t)

struct the_c1 {
    alignas(4) uint8_t a;
    alignas(4) little_whale_c2_t x1;
    alignas(4) uint32_t x2;
    alignas(2) int16_t x3;
    alignas(2) uint8_t __deprecated0[4]; /* was: 'light' */
};
static_assert(sizeof(the_c1_t) == 20, "struct size mismatch");

static inline const the_c1_t *the_c1__const_ptr_add(const the_c1_t *p, size_t i) { return p + i; }
static inline the_c1_t *the_c1__ptr_add(the_c1_t *p, size_t i) { return p + i; }
static inline the_c1_struct_t the_c1_vec_at(the_c1_vec_t vec, size_t i)
__flatbuffers_struct_vec_at(vec, i)
static inline size_t the_c1__size(void) { return 20; }
static inline size_t the_c1_vec_len(the_c1_vec_t vec)
__flatbuffers_vec_len(vec)
__flatbuffers_struct_as_root(the_c1)

__flatbuffers_define_struct_scalar_field(the_c1, a, flatbuffers_uint8, uint8_t)
__flatbuffers_define_struct_struct_field(the_c1, x1, little_whale_c2_struct_t)
__flatbuffers_define_struct_scalar_field(the_c1, x2, flatbuffers_uint32, uint32_t)
__flatbuffers_define_struct_scalar_field(the_c1, x3, flatbuffers_int16, int16_t)


/** ///////////////////////////////////////////////////////
 * /////////////////////////////////////////////////////// */
struct point_table { uint8_t unused__; };

static inline size_t point_vec_len(point_vec_t vec)
__flatbuffers_vec_len(vec)
static inline point_table_t point_vec_at(point_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(point_table_t, vec, i, 0)
__flatbuffers_table_as_root(point)

__flatbuffers_define_scalar_field(0, point, x, flatbuffers_float, float, 0.00000000f)
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(point, x, float)
__flatbuffers_define_table_sort_by_scalar_field(point, x, float)
__flatbuffers_define_default_find_by_scalar_field(point, x, float)
__flatbuffers_define_default_scan_by_scalar_field(point, x, float)
#define point_vec_sort point_vec_sort_by_x
__flatbuffers_define_scalar_field(1, point, y, flatbuffers_float, float, 0.00000000f)
__flatbuffers_define_scalar_field(2, point, z, flatbuffers_float, float, 0.00000000f)
/* Note: this is not the primary key of this table. */
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(point, z, float)
__flatbuffers_define_table_sort_by_scalar_field(point, z, float)

/** ********** ANOTHER DOC CASE ************ */
struct mystic_island_table { uint8_t unused__; };

static inline size_t mystic_island_vec_len(mystic_island_vec_t vec)
__flatbuffers_vec_len(vec)
static inline mystic_island_table_t mystic_island_vec_at(mystic_island_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(mystic_island_table_t, vec, i, 0)
__flatbuffers_table_as_root(mystic_island)

__flatbuffers_define_scalar_field(0, mystic_island, lattitude, flatbuffers_int32, int32_t, INT32_C(0))
__flatbuffers_define_scalar_field(1, mystic_island, longitude, flatbuffers_int32, int32_t, INT32_C(0))

/**  There are two different point tables
 *  - one in each name space. */
struct mystic_point_table { uint8_t unused__; };

static inline size_t mystic_point_vec_len(mystic_point_vec_t vec)
__flatbuffers_vec_len(vec)
static inline mystic_point_table_t mystic_point_vec_at(mystic_point_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(mystic_point_table_t, vec, i, 0)
__flatbuffers_table_as_root(mystic_point)

__flatbuffers_define_scalar_field(0, mystic_point, interest, mystic_agent, mystic_agent_enum_t, INT32_C(0))
__flatbuffers_define_string_field(1, mystic_point, blank, 0)
__flatbuffers_define_table_field(2, mystic_point, geo, mystic_island_table_t, 0)
/**  the.ui is a union
 * 
 *  We got one blank comment line above. */
typedef uint8_t the_u1_union_type_t;
__flatbuffers_define_integer_type(the_u1, the_u1_union_type_t, 8)
__flatbuffers_define_union(flatbuffers_, the_u1)
#define the_u1_NONE ((the_u1_union_type_t)UINT8_C(0))
/**  Note that the.point is different from mystic.point in other namespace. */
#define the_u1_point ((the_u1_union_type_t)UINT8_C(2))
#define the_u1_foo ((the_u1_union_type_t)UINT8_C(4))
#define the_u1_island ((the_u1_union_type_t)UINT8_C(17))

static inline const char *the_u1_type_name(the_u1_union_type_t type)
{
    switch (type) {
    case the_u1_NONE: return "NONE";
    case the_u1_point: return "point";
    case the_u1_foo: return "foo";
    case the_u1_island: return "island";
    default: return "";
    }
}

static inline int the_u1_is_known_type(the_u1_union_type_t type)
{
    switch (type) {
    case the_u1_NONE: return 1;
    case the_u1_point: return 1;
    case the_u1_foo: return 1;
    case the_u1_island: return 1;
    default: return 0;
    }
}


struct the_foo_table { uint8_t unused__; };

static inline size_t the_foo_vec_len(the_foo_vec_t vec)
__flatbuffers_vec_len(vec)
static inline the_foo_table_t the_foo_vec_at(the_foo_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(the_foo_table_t, vec, i, 0)
__flatbuffers_table_as_root(the_foo)

__flatbuffers_define_union_field(flatbuffers_, 1, the_foo, m, the_u1, 0)
__flatbuffers_define_scalar_field(2, the_foo, e, the_e1, the_e1_enum_t, INT16_C(-2))
/* Note: find only works on vectors sorted by this field. */
__flatbuffers_define_find_by_scalar_field(the_foo, e, the_e1_enum_t)
__flatbuffers_define_table_sort_by_scalar_field(the_foo, e, the_e1_enum_t)
__flatbuffers_define_default_find_by_scalar_field(the_foo, e, the_e1_enum_t)
__flatbuffers_define_default_scan_by_scalar_field(the_foo, e, the_e1_enum_t)
#define the_foo_vec_sort the_foo_vec_sort_by_e
__flatbuffers_define_scalar_field(3, the_foo, x, flatbuffers_int32, int32_t, INT32_C(2))
__flatbuffers_define_scalar_field(4, the_foo, interest, mystic_agent, mystic_agent_enum_t, INT32_C(1))
__flatbuffers_define_scalar_field(5, the_foo, strange, mystic_agent, mystic_agent_enum_t, INT32_C(1))

struct the_goo_table { uint8_t unused__; };

static inline size_t the_goo_vec_len(the_goo_vec_t vec)
__flatbuffers_vec_len(vec)
static inline the_goo_table_t the_goo_vec_at(the_goo_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(the_goo_table_t, vec, i, 0)
__flatbuffers_table_as_root(the_goo)

__flatbuffers_define_string_field(0, the_goo, hello, 1)
__flatbuffers_define_find_by_string_field(the_goo, hello)
__flatbuffers_define_table_sort_by_string_field(the_goo, hello)
__flatbuffers_define_default_find_by_string_field(the_goo, hello)
__flatbuffers_define_default_scan_by_string_field(the_goo, hello)
#define the_goo_vec_sort the_goo_vec_sort_by_hello
__flatbuffers_define_vector_field(1, the_goo, confirmations, the_confirm_vec_t, 0)
/* Skipping deprecated field: 'the_goo_never_mind' */

__flatbuffers_define_vector_field(3, the_goo, embedded_t, flatbuffers_uint8_vec_t, 0)
__flatbuffers_nested_buffer_as_root(the_goo, embedded_t, the_foo, table_)
__flatbuffers_define_vector_field(4, the_goo, embedded_s, flatbuffers_uint8_vec_t, 0)
__flatbuffers_nested_buffer_as_root(the_goo, embedded_s, little_whale_c2, struct_)
__flatbuffers_define_struct_field(5, the_goo, shady, the_shade_struct_t, 0)

struct little_whale_hop_table { uint8_t unused__; };

static inline size_t little_whale_hop_vec_len(little_whale_hop_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_hop_table_t little_whale_hop_vec_at(little_whale_hop_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_hop_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_hop)

__flatbuffers_define_struct_field(0, little_whale_hop, einhorn, little_whale_c3_struct_t, 1)
__flatbuffers_define_struct_field(1, little_whale_hop, jupiter, little_whale_c2_struct_t, 0)
__flatbuffers_define_vector_field(2, little_whale_hop, names, flatbuffers_string_vec_t, 1)
__flatbuffers_define_vector_field(3, little_whale_hop, ehlist, little_whale_c3_vec_t, 0)
__flatbuffers_define_table_field(4, little_whale_hop, k2, the_goo_table_t, 0)
__flatbuffers_define_vector_field(5, little_whale_hop, k2vec, the_goo_vec_t, 0)
__flatbuffers_define_scalar_field(6, little_whale_hop, lunar, the_flags2, the_flags2_enum_t, UINT32_C(4))

struct little_whale_TestOrder_table { uint8_t unused__; };

static inline size_t little_whale_TestOrder_vec_len(little_whale_TestOrder_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_TestOrder_table_t little_whale_TestOrder_vec_at(little_whale_TestOrder_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_TestOrder_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_TestOrder)

__flatbuffers_define_scalar_field(0, little_whale_TestOrder, x0, flatbuffers_int8, int8_t, INT8_C(0))
__flatbuffers_define_scalar_field(1, little_whale_TestOrder, x1, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(1))
__flatbuffers_define_scalar_field(2, little_whale_TestOrder, x2, flatbuffers_int16, int16_t, INT16_C(0))
__flatbuffers_define_struct_field(3, little_whale_TestOrder, x3, the_shade_struct_t, 0)
__flatbuffers_define_string_field(4, little_whale_TestOrder, x4, 0)
__flatbuffers_define_union_field(flatbuffers_, 6, little_whale_TestOrder, x5, the_u1, 0)
__flatbuffers_define_vector_field(7, little_whale_TestOrder, x6, flatbuffers_string_vec_t, 0)
__flatbuffers_define_scalar_field(8, little_whale_TestOrder, x7, flatbuffers_double, double, 0.0000000000000000)

struct little_whale_TestOrder2_table { uint8_t unused__; };

static inline size_t little_whale_TestOrder2_vec_len(little_whale_TestOrder2_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_TestOrder2_table_t little_whale_TestOrder2_vec_at(little_whale_TestOrder2_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_TestOrder2_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_TestOrder2)

__flatbuffers_define_scalar_field(0, little_whale_TestOrder2, x0, flatbuffers_int8, int8_t, INT8_C(0))
__flatbuffers_define_scalar_field(1, little_whale_TestOrder2, x1, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(1))
__flatbuffers_define_scalar_field(2, little_whale_TestOrder2, x1a, flatbuffers_bool, flatbuffers_bool_t, UINT8_C(1))
__flatbuffers_define_scalar_field(3, little_whale_TestOrder2, x2, flatbuffers_int16, int16_t, INT16_C(0))
__flatbuffers_define_struct_field(4, little_whale_TestOrder2, x3, the_shade_struct_t, 0)
__flatbuffers_define_string_field(5, little_whale_TestOrder2, x4, 0)
__flatbuffers_define_union_field(flatbuffers_, 7, little_whale_TestOrder2, x5, the_u1, 0)
__flatbuffers_define_vector_field(8, little_whale_TestOrder2, x6, flatbuffers_string_vec_t, 0)
__flatbuffers_define_scalar_field(9, little_whale_TestOrder2, x7, flatbuffers_double, double, 0.0000000000000000)

struct little_whale_StoreResponse_table { uint8_t unused__; };

static inline size_t little_whale_StoreResponse_vec_len(little_whale_StoreResponse_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_StoreResponse_table_t little_whale_StoreResponse_vec_at(little_whale_StoreResponse_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_StoreResponse_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_StoreResponse)


struct little_whale_Monster_table { uint8_t unused__; };

static inline size_t little_whale_Monster_vec_len(little_whale_Monster_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_Monster_table_t little_whale_Monster_vec_at(little_whale_Monster_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_Monster_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_Monster)


struct little_whale_MonsterId_table { uint8_t unused__; };

static inline size_t little_whale_MonsterId_vec_len(little_whale_MonsterId_vec_t vec)
__flatbuffers_vec_len(vec)
static inline little_whale_MonsterId_table_t little_whale_MonsterId_vec_at(little_whale_MonsterId_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(little_whale_MonsterId_table_t, vec, i, 0)
__flatbuffers_table_as_root(little_whale_MonsterId)

__flatbuffers_define_scalar_field(0, little_whale_MonsterId, id, flatbuffers_int32, int32_t, INT32_C(0))


#include "flatcc/flatcc_epilogue.h"
#endif /* XYZZY_READER_H */
#ifndef XYZZY_BUILDER_H
#define XYZZY_BUILDER_H

/* Generated by flatcc 0.6.1-dev FlatBuffers schema compiler for C by dvide.com */

#ifndef XYZZY_READER_H
#include "xyzzy_reader.h"
#endif
#ifndef FLATBUFFERS_COMMON_BUILDER_H
#include "flatbuffers_common_builder.h"
#endif
#include "flatcc/flatcc_prologue.h"
#undef flatbuffers_identifier
#define flatbuffers_identifier "fbuz"
#undef flatbuffers_extension
#define flatbuffers_extension ".cgen_test"

#define __mystic_agent_formal_args , mystic_agent_enum_t v0
#define __mystic_agent_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, mystic_agent, mystic_agent_enum_t)
#define __the_e1_formal_args , the_e1_enum_t v0
#define __the_e1_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, the_e1, the_e1_enum_t)
#define __the_flags_formal_args , the_flags_enum_t v0
#define __the_flags_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, the_flags, the_flags_enum_t)
#define __the_flags2_formal_args , the_flags2_enum_t v0
#define __the_flags2_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, the_flags2, the_flags2_enum_t)
#define __the_confirm_formal_args , the_confirm_enum_t v0
#define __the_confirm_call_args , v0
__flatbuffers_build_scalar(flatbuffers_, the_confirm, the_confirm_enum_t)

#define __the_shade_formal_args , int8_t v0, int8_t v1, int8_t v2, uint8_t v3
#define __the_shade_call_args , v0, v1, v2, v3
static inline the_shade_t *the_shade_assign(the_shade_t *p, int8_t v0, int8_t v1, int8_t v2, uint8_t v3)
{ p->x = v0; p->y = v1; p->z = v2; p->alpha = v3;
  return p; }
static inline the_shade_t *the_shade_copy(the_shade_t *p, const the_shade_t *p2)
{ p->x = p2->x; p->y = p2->y; p->z = p2->z; p->alpha = p2->alpha;
  return p; }
static inline the_shade_t *the_shade_assign_to_pe(the_shade_t *p, int8_t v0, int8_t v1, int8_t v2, uint8_t v3)
{ p->x = v0; p->y = v1; p->z = v2; p->alpha = v3;
  return p; }
static inline the_shade_t *the_shade_copy_to_pe(the_shade_t *p, const the_shade_t *p2)
{ p->x = p2->x; p->y = p2->y; p->z = p2->z; p->alpha = p2->alpha;
  return p; }
static inline the_shade_t *the_shade_assign_from_pe(the_shade_t *p, int8_t v0, int8_t v1, int8_t v2, uint8_t v3)
{ p->x = v0; p->y = v1; p->z = v2; p->alpha = v3;
  return p; }
static inline the_shade_t *the_shade_copy_from_pe(the_shade_t *p, const the_shade_t *p2)
{ p->x = p2->x; p->y = p2->y; p->z = p2->z; p->alpha = p2->alpha;
  return p; }
__flatbuffers_build_struct(flatbuffers_, the_shade, 4, 2, the_shade_file_identifier, the_shade_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, the_shade, the_shade_t)

#define __the_notify_formal_args , the_confirm_enum_t v0, the_confirm_enum_t v1, the_flags_enum_t v2
#define __the_notify_call_args , v0, v1, v2
static inline the_notify_t *the_notify_assign(the_notify_t *p, the_confirm_enum_t v0, the_confirm_enum_t v1, the_flags_enum_t v2)
{ p->primary_recipient = v0; p->secondary_recipient = v1; p->flags = v2;
  return p; }
static inline the_notify_t *the_notify_copy(the_notify_t *p, const the_notify_t *p2)
{ p->primary_recipient = p2->primary_recipient; p->secondary_recipient = p2->secondary_recipient; p->flags = p2->flags;
  return p; }
static inline the_notify_t *the_notify_assign_to_pe(the_notify_t *p, the_confirm_enum_t v0, the_confirm_enum_t v1, the_flags_enum_t v2)
{ p->primary_recipient = v0; p->secondary_recipient = v1; the_flags_assign_to_pe(&p->flags, v2);
  return p; }
static inline the_notify_t *the_notify_copy_to_pe(the_notify_t *p, const the_notify_t *p2)
{ p->primary_recipient = p2->primary_recipient; p->secondary_recipient = p2->secondary_recipient; the_flags_copy_to_pe(&p->flags, &p2->flags);
  return p; }
static inline the_notify_t *the_notify_assign_from_pe(the_notify_t *p, the_confirm_enum_t v0, the_confirm_enum_t v1, the_flags_enum_t v2)
{ p->primary_recipient = v0; p->secondary_recipient = v1; the_flags_assign_from_pe(&p->flags, v2);
  return p; }
static inline the_notify_t *the_notify_copy_from_pe(the_notify_t *p, const the_notify_t *p2)
{ p->primary_recipient = p2->primary_recipient; p->secondary_recipient = p2->secondary_recipient; the_flags_copy_from_pe(&p->flags, &p2->flags);
  return p; }
__flatbuffers_build_struct(flatbuffers_, the_notify, 4, 2, the_notify_file_identifier, the_notify_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, the_notify, the_notify_t)

#define __the_s1_formal_args , int32_t v0
#define __the_s1_call_args , v0
static inline the_s1_t *the_s1_assign(the_s1_t *p, int32_t v0)
{ p->index = v0;
  return p; }
static inline the_s1_t *the_s1_copy(the_s1_t *p, const the_s1_t *p2)
{ p->index = p2->index;
  return p; }
static inline the_s1_t *the_s1_assign_to_pe(the_s1_t *p, int32_t v0)
{ flatbuffers_int32_assign_to_pe(&p->index, v0);
  return p; }
static inline the_s1_t *the_s1_copy_to_pe(the_s1_t *p, const the_s1_t *p2)
{ flatbuffers_int32_copy_to_pe(&p->index, &p2->index);
  return p; }
static inline the_s1_t *the_s1_assign_from_pe(the_s1_t *p, int32_t v0)
{ flatbuffers_int32_assign_from_pe(&p->index, v0);
  return p; }
static inline the_s1_t *the_s1_copy_from_pe(the_s1_t *p, const the_s1_t *p2)
{ flatbuffers_int32_copy_from_pe(&p->index, &p2->index);
  return p; }
__flatbuffers_build_struct(flatbuffers_, the_s1, 4, 4, the_s1_file_identifier, the_s1_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, the_s1, the_s1_t)

#define __little_whale_c3_formal_args , int32_t v0
#define __little_whale_c3_call_args , v0
static inline little_whale_c3_t *little_whale_c3_assign(little_whale_c3_t *p, int32_t v0)
{ the_s1_assign(&p->z, v0);
  return p; }
static inline little_whale_c3_t *little_whale_c3_copy(little_whale_c3_t *p, const little_whale_c3_t *p2)
{ the_s1_copy(&p->z, &p2->z);
  return p; }
static inline little_whale_c3_t *little_whale_c3_assign_to_pe(little_whale_c3_t *p, int32_t v0)
{ the_s1_assign_to_pe(&p->z, v0);
  return p; }
static inline little_whale_c3_t *little_whale_c3_copy_to_pe(little_whale_c3_t *p, const little_whale_c3_t *p2)
{ the_s1_copy_to_pe(&p->z, &p2->z);
  return p; }
static inline little_whale_c3_t *little_whale_c3_assign_from_pe(little_whale_c3_t *p, int32_t v0)
{ the_s1_assign_from_pe(&p->z, v0);
  return p; }
static inline little_whale_c3_t *little_whale_c3_copy_from_pe(little_whale_c3_t *p, const little_whale_c3_t *p2)
{ the_s1_copy_from_pe(&p->z, &p2->z);
  return p; }
__flatbuffers_build_struct(flatbuffers_, little_whale_c3, 4, 4, little_whale_c3_file_identifier, little_whale_c3_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, little_whale_c3, little_whale_c3_t)

#define __little_whale_c2_formal_args , int32_t v0
#define __little_whale_c2_call_args , v0
static inline little_whale_c2_t *little_whale_c2_assign(little_whale_c2_t *p, int32_t v0)
{ little_whale_c3_assign(&p->y, v0);
  return p; }
static inline little_whale_c2_t *little_whale_c2_copy(little_whale_c2_t *p, const little_whale_c2_t *p2)
{ little_whale_c3_copy(&p->y, &p2->y);
  return p; }
static inline little_whale_c2_t *little_whale_c2_assign_to_pe(little_whale_c2_t *p, int32_t v0)
{ little_whale_c3_assign_to_pe(&p->y, v0);
  return p; }
static inline little_whale_c2_t *little_whale_c2_copy_to_pe(little_whale_c2_t *p, const little_whale_c2_t *p2)
{ little_whale_c3_copy_to_pe(&p->y, &p2->y);
  return p; }
static inline little_whale_c2_t *little_whale_c2_assign_from_pe(little_whale_c2_t *p, int32_t v0)
{ little_whale_c3_assign_from_pe(&p->y, v0);
  return p; }
static inline little_whale_c2_t *little_whale_c2_copy_from_pe(little_whale_c2_t *p, const little_whale_c2_t *p2)
{ little_whale_c3_copy_from_pe(&p->y, &p2->y);
  return p; }
__flatbuffers_build_struct(flatbuffers_, little_whale_c2, 4, 4, little_whale_c2_file_identifier, little_whale_c2_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, little_whale_c2, little_whale_c2_t)

#define __the_c1_formal_args , uint8_t v0, int32_t v1, uint32_t v2, int16_t v3
#define __the_c1_call_args , v0, v1, v2, v3
static inline the_c1_t *the_c1_assign(the_c1_t *p, uint8_t v0, int32_t v1, uint32_t v2, int16_t v3)
{ p->a = v0; little_whale_c2_assign(&p->x1, v1); p->x2 = v2; p->x3 = v3;
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
static inline the_c1_t *the_c1_copy(the_c1_t *p, const the_c1_t *p2)
{ p->a = p2->a; little_whale_c2_copy(&p->x1, &p2->x1); p->x2 = p2->x2; p->x3 = p2->x3;
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
static inline the_c1_t *the_c1_assign_to_pe(the_c1_t *p, uint8_t v0, int32_t v1, uint32_t v2, int16_t v3)
{ p->a = v0; little_whale_c2_assign_to_pe(&p->x1, v1); flatbuffers_uint32_assign_to_pe(&p->x2, v2); flatbuffers_int16_assign_to_pe(&p->x3, v3);
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
static inline the_c1_t *the_c1_copy_to_pe(the_c1_t *p, const the_c1_t *p2)
{ p->a = p2->a; little_whale_c2_copy_to_pe(&p->x1, &p2->x1); flatbuffers_uint32_copy_to_pe(&p->x2, &p2->x2); flatbuffers_int16_copy_to_pe(&p->x3, &p2->x3);
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
static inline the_c1_t *the_c1_assign_from_pe(the_c1_t *p, uint8_t v0, int32_t v1, uint32_t v2, int16_t v3)
{ p->a = v0; little_whale_c2_assign_from_pe(&p->x1, v1); flatbuffers_uint32_assign_from_pe(&p->x2, v2); flatbuffers_int16_assign_from_pe(&p->x3, v3);
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
static inline the_c1_t *the_c1_copy_from_pe(the_c1_t *p, const the_c1_t *p2)
{ p->a = p2->a; little_whale_c2_copy_from_pe(&p->x1, &p2->x1); flatbuffers_uint32_copy_from_pe(&p->x2, &p2->x2); flatbuffers_int16_copy_from_pe(&p->x3, &p2->x3);
  __flatbuffers_struct_clear_field(p->__deprecated0);
  return p; }
__flatbuffers_build_struct(flatbuffers_, the_c1, 20, 4, the_c1_file_identifier, the_c1_type_identifier)
__flatbuffers_define_fixed_array_primitives(flatbuffers_, the_c1, the_c1_t)

typedef flatbuffers_union_ref_t the_u1_union_ref_t;
typedef flatbuffers_union_vec_ref_t the_u1_union_vec_ref_t;
static the_u1_union_ref_t the_u1_clone(flatbuffers_builder_t *B, the_u1_union_t t);

static const flatbuffers_voffset_t __point_required[] = { 0 };
typedef flatbuffers_ref_t point_ref_t;
static point_ref_t point_clone(flatbuffers_builder_t *B, point_table_t t);
__flatbuffers_build_table(flatbuffers_, point, 3)

static const flatbuffers_voffset_t __mystic_island_required[] = { 0 };
typedef flatbuffers_ref_t mystic_island_ref_t;
static mystic_island_ref_t mystic_island_clone(flatbuffers_builder_t *B, mystic_island_table_t t);
__flatbuffers_build_table(flatbuffers_, mystic_island, 2)

static const flatbuffers_voffset_t __mystic_point_required[] = { 0 };
typedef flatbuffers_ref_t mystic_point_ref_t;
static mystic_point_ref_t mystic_point_clone(flatbuffers_builder_t *B, mystic_point_table_t t);
__flatbuffers_build_table(flatbuffers_, mystic_point, 3)

static const flatbuffers_voffset_t __the_foo_required[] = { 0 };
typedef flatbuffers_ref_t the_foo_ref_t;
static the_foo_ref_t the_foo_clone(flatbuffers_builder_t *B, the_foo_table_t t);
__flatbuffers_build_table(flatbuffers_, the_foo, 6)

static const flatbuffers_voffset_t __the_goo_required[] = { 0, 0 };
typedef flatbuffers_ref_t the_goo_ref_t;
static the_goo_ref_t the_goo_clone(flatbuffers_builder_t *B, the_goo_table_t t);
__flatbuffers_build_table(flatbuffers_, the_goo, 6)

static const flatbuffers_voffset_t __little_whale_hop_required[] = { 0, 2, 0 };
typedef flatbuffers_ref_t little_whale_hop_ref_t;
static little_whale_hop_ref_t little_whale_hop_clone(flatbuffers_builder_t *B, little_whale_hop_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_hop, 7)

static const flatbuffers_voffset_t __little_whale_TestOrder_required[] = { 0 };
typedef flatbuffers_ref_t little_whale_TestOrder_ref_t;
static little_whale_TestOrder_ref_t little_whale_TestOrder_clone(flatbuffers_builder_t *B, little_whale_TestOrder_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_TestOrder, 9)

static const flatbuffers_voffset_t __little_whale_TestOrder2_required[] = { 0 };
typedef flatbuffers_ref_t little_whale_TestOrder2_ref_t;
static little_whale_TestOrder2_ref_t little_whale_TestOrder2_clone(flatbuffers_builder_t *B, little_whale_TestOrder2_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_TestOrder2, 10)

static const flatbuffers_voffset_t __little_whale_StoreResponse_required[] = { 0 };
typedef flatbuffers_ref_t little_whale_StoreResponse_ref_t;
static little_whale_StoreResponse_ref_t little_whale_StoreResponse_clone(flatbuffers_builder_t *B, little_whale_StoreResponse_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_StoreResponse, 0)

static const flatbuffers_voffset_t __little_whale_Monster_required[] = { 0 };
typedef flatbuffers_ref_t little_whale_Monster_ref_t;
static little_whale_Monster_ref_t little_whale_Monster_clone(flatbuffers_builder_t *B, little_whale_Monster_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_Monster, 0)

static const flatbuffers_voffset_t __little_whale_MonsterId_required[] = { 0 };
typedef flatbuffers_ref_t little_whale_MonsterId_ref_t;
static little_whale_MonsterId_ref_t little_whale_MonsterId_clone(flatbuffers_builder_t *B, little_whale_MonsterId_table_t t);
__flatbuffers_build_table(flatbuffers_, little_whale_MonsterId, 1)

#define __point_formal_args , float v0, float v1, float v2
#define __point_call_args , v0, v1, v2
static inline point_ref_t point_create(flatbuffers_builder_t *B __point_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, point, point_file_identifier, point_type_identifier)

#define __mystic_island_formal_args , int32_t v0, int32_t v1
#define __mystic_island_call_args , v0, v1
static inline mystic_island_ref_t mystic_island_create(flatbuffers_builder_t *B __mystic_island_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, mystic_island, mystic_island_file_identifier, mystic_island_type_identifier)

#define __mystic_point_formal_args , mystic_agent_enum_t v0, flatbuffers_string_ref_t v1, mystic_island_ref_t v2
#define __mystic_point_call_args , v0, v1, v2
static inline mystic_point_ref_t mystic_point_create(flatbuffers_builder_t *B __mystic_point_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, mystic_point, mystic_point_file_identifier, mystic_point_type_identifier)

#define __the_foo_formal_args ,\
  the_u1_union_ref_t v1, the_e1_enum_t v2, int32_t v3, mystic_agent_enum_t v4, mystic_agent_enum_t v5
#define __the_foo_call_args ,\
  v1, v2, v3, v4, v5
static inline the_foo_ref_t the_foo_create(flatbuffers_builder_t *B __the_foo_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, the_foo, the_foo_file_identifier, the_foo_type_identifier)

#define __the_goo_formal_args ,\
  flatbuffers_string_ref_t v0, the_confirm_vec_ref_t v1, flatbuffers_uint8_vec_ref_t v3, flatbuffers_uint8_vec_ref_t v4, the_shade_t *v5
#define __the_goo_call_args ,\
  v0, v1, v3, v4, v5
static inline the_goo_ref_t the_goo_create(flatbuffers_builder_t *B __the_goo_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, the_goo, the_goo_file_identifier, the_goo_type_identifier)

#define __little_whale_hop_formal_args ,\
  little_whale_c3_t *v0, little_whale_c2_t *v1, flatbuffers_string_vec_ref_t v2, little_whale_c3_vec_ref_t v3,\
  the_goo_ref_t v4, the_goo_vec_ref_t v5, the_flags2_enum_t v6
#define __little_whale_hop_call_args ,\
  v0, v1, v2, v3,\
  v4, v5, v6
static inline little_whale_hop_ref_t little_whale_hop_create(flatbuffers_builder_t *B __little_whale_hop_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_hop, little_whale_hop_file_identifier, little_whale_hop_type_identifier)

#define __little_whale_TestOrder_formal_args ,\
  int8_t v0, flatbuffers_bool_t v1, int16_t v2, the_shade_t *v3,\
  flatbuffers_string_ref_t v4, the_u1_union_ref_t v6, flatbuffers_string_vec_ref_t v7, double v8
#define __little_whale_TestOrder_call_args ,\
  v0, v1, v2, v3,\
  v4, v6, v7, v8
static inline little_whale_TestOrder_ref_t little_whale_TestOrder_create(flatbuffers_builder_t *B __little_whale_TestOrder_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_TestOrder, little_whale_TestOrder_file_identifier, little_whale_TestOrder_type_identifier)

#define __little_whale_TestOrder2_formal_args ,\
  int8_t v0, flatbuffers_bool_t v1, flatbuffers_bool_t v2, int16_t v3,\
  the_shade_t *v4, flatbuffers_string_ref_t v5, the_u1_union_ref_t v7, flatbuffers_string_vec_ref_t v8, double v9
#define __little_whale_TestOrder2_call_args ,\
  v0, v1, v2, v3,\
  v4, v5, v7, v8, v9
static inline little_whale_TestOrder2_ref_t little_whale_TestOrder2_create(flatbuffers_builder_t *B __little_whale_TestOrder2_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_TestOrder2, little_whale_TestOrder2_file_identifier, little_whale_TestOrder2_type_identifier)

#define __little_whale_StoreResponse_formal_args 
#define __little_whale_StoreResponse_call_args 
static inline little_whale_StoreResponse_ref_t little_whale_StoreResponse_create(flatbuffers_builder_t *B __little_whale_StoreResponse_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_StoreResponse, little_whale_StoreResponse_file_identifier, little_whale_StoreResponse_type_identifier)

#define __little_whale_Monster_formal_args 
#define __little_whale_Monster_call_args 
static inline little_whale_Monster_ref_t little_whale_Monster_create(flatbuffers_builder_t *B __little_whale_Monster_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_Monster, little_whale_Monster_file_identifier, little_whale_Monster_type_identifier)

#define __little_whale_MonsterId_formal_args , int32_t v0
#define __little_whale_MonsterId_call_args , v0
static inline little_whale_MonsterId_ref_t little_whale_MonsterId_create(flatbuffers_builder_t *B __little_whale_MonsterId_formal_args);
__flatbuffers_build_table_prolog(flatbuffers_, little_whale_MonsterId, little_whale_MonsterId_file_identifier, little_whale_MonsterId_type_identifier)

static inline the_u1_union_ref_t the_u1_as_NONE(void)
{ the_u1_union_ref_t uref; uref.type = the_u1_NONE; uref.value = 0; return uref; }
static inline the_u1_union_ref_t the_u1_as_point(point_ref_t ref)
{ the_u1_union_ref_t uref; uref.type = the_u1_point; uref.value = ref; return uref; }
static inline the_u1_union_ref_t the_u1_as_foo(the_foo_ref_t ref)
{ the_u1_union_ref_t uref; uref.type = the_u1_foo; uref.value = ref; return uref; }
static inline the_u1_union_ref_t the_u1_as_island(mystic_island_ref_t ref)
{ the_u1_union_ref_t uref; uref.type = the_u1_island; uref.value = ref; return uref; }
__flatbuffers_build_union_vector(flatbuffers_, the_u1)

static the_u1_union_ref_t the_u1_clone(flatbuffers_builder_t *B, the_u1_union_t u)
{
    switch (u.type) {
    case 2: return the_u1_as_point(point_clone(B, (point_table_t)u.value));
    case 4: return the_u1_as_foo(the_foo_clone(B, (the_foo_table_t)u.value));
    case 17: return the_u1_as_island(mystic_island_clone(B, (mystic_island_table_t)u.value));
    default: return the_u1_as_NONE();
    }
}

__flatbuffers_build_scalar_field(0, flatbuffers_, point_x, flatbuffers_float, float, 4, 4, 0.00000000f, point)
__flatbuffers_build_scalar_field(1, flatbuffers_, point_y, flatbuffers_float, float, 4, 4, 0.00000000f, point)
__flatbuffers_build_scalar_field(2, flatbuffers_, point_z, flatbuffers_float, float, 4, 4, 0.00000000f, point)

static inline point_ref_t point_create(flatbuffers_builder_t *B __point_formal_args)
{
    if (point_start(B)
        || point_x_add(B, v0)
        || point_y_add(B, v1)
        || point_z_add(B, v2)) {
        return 0;
    }
    return point_end(B);
}

static point_ref_t point_clone(flatbuffers_builder_t *B, point_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (point_start(B)
        || point_x_pick(B, t)
        || point_y_pick(B, t)
        || point_z_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, point_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, mystic_island_lattitude, flatbuffers_int32, int32_t, 4, 4, INT32_C(0), mystic_island)
__flatbuffers_build_scalar_field(1, flatbuffers_, mystic_island_longitude, flatbuffers_int32, int32_t, 4, 4, INT32_C(0), mystic_island)

static inline mystic_island_ref_t mystic_island_create(flatbuffers_builder_t *B __mystic_island_formal_args)
{
    if (mystic_island_start(B)
        || mystic_island_lattitude_add(B, v0)
        || mystic_island_longitude_add(B, v1)) {
        return 0;
    }
    return mystic_island_end(B);
}

static mystic_island_ref_t mystic_island_clone(flatbuffers_builder_t *B, mystic_island_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (mystic_island_start(B)
        || mystic_island_lattitude_pick(B, t)
        || mystic_island_longitude_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, mystic_island_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, mystic_point_interest, mystic_agent, mystic_agent_enum_t, 4, 4, INT32_C(0), mystic_point)
__flatbuffers_build_string_field(1, flatbuffers_, mystic_point_blank, mystic_point)
__flatbuffers_build_table_field(2, flatbuffers_, mystic_point_geo, mystic_island, mystic_point)

static inline mystic_point_ref_t mystic_point_create(flatbuffers_builder_t *B __mystic_point_formal_args)
{
    if (mystic_point_start(B)
        || mystic_point_interest_add(B, v0)
        || mystic_point_blank_add(B, v1)
        || mystic_point_geo_add(B, v2)) {
        return 0;
    }
    return mystic_point_end(B);
}

static mystic_point_ref_t mystic_point_clone(flatbuffers_builder_t *B, mystic_point_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (mystic_point_start(B)
        || mystic_point_interest_pick(B, t)
        || mystic_point_blank_pick(B, t)
        || mystic_point_geo_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, mystic_point_end(B));
}

__flatbuffers_build_union_field(1, flatbuffers_, the_foo_m, the_u1, the_foo)
__flatbuffers_build_union_table_value_field(flatbuffers_, the_foo_m, the_u1, point, point)
__flatbuffers_build_union_table_value_field(flatbuffers_, the_foo_m, the_u1, foo, the_foo)
__flatbuffers_build_union_table_value_field(flatbuffers_, the_foo_m, the_u1, island, mystic_island)
__flatbuffers_build_scalar_field(2, flatbuffers_, the_foo_e, the_e1, the_e1_enum_t, 2, 2, INT16_C(-2), the_foo)
__flatbuffers_build_scalar_field(3, flatbuffers_, the_foo_x, flatbuffers_int32, int32_t, 4, 4, INT32_C(2), the_foo)
__flatbuffers_build_scalar_field(4, flatbuffers_, the_foo_interest, mystic_agent, mystic_agent_enum_t, 4, 4, INT32_C(1), the_foo)
__flatbuffers_build_scalar_field(5, flatbuffers_, the_foo_strange, mystic_agent, mystic_agent_enum_t, 4, 4, INT32_C(1), the_foo)

static inline the_foo_ref_t the_foo_create(flatbuffers_builder_t *B __the_foo_formal_args)
{
    if (the_foo_start(B)
        || the_foo_m_add_value(B, v1)
        || the_foo_x_add(B, v3)
        || the_foo_interest_add(B, v4)
        || the_foo_strange_add(B, v5)
        || the_foo_e_add(B, v2)
        || the_foo_m_add_type(B, v1.type)) {
        return 0;
    }
    return the_foo_end(B);
}

static the_foo_ref_t the_foo_clone(flatbuffers_builder_t *B, the_foo_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (the_foo_start(B)
        || the_foo_m_pick(B, t)
        || the_foo_x_pick(B, t)
        || the_foo_interest_pick(B, t)
        || the_foo_strange_pick(B, t)
        || the_foo_e_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, the_foo_end(B));
}

__flatbuffers_build_string_field(0, flatbuffers_, the_goo_hello, the_goo)
__flatbuffers_build_vector_field(1, flatbuffers_, the_goo_confirmations, the_confirm, the_confirm_enum_t, the_goo)
/* Skipping build of deprecated field: 'the_goo_never_mind' */

__flatbuffers_build_vector_field(3, flatbuffers_, the_goo_embedded_t, flatbuffers_uint8, uint8_t, the_goo)
__flatbuffers_build_nested_table_root(flatbuffers_, the_goo_embedded_t, the_foo, the_foo_identifier, the_foo_type_identifier)
__flatbuffers_build_vector_field(4, flatbuffers_, the_goo_embedded_s, flatbuffers_uint8, uint8_t, the_goo)
__flatbuffers_build_nested_struct_root(flatbuffers_, the_goo_embedded_s, little_whale_c2, 4, little_whale_c2_identifier, little_whale_c2_type_identifier)
__flatbuffers_build_struct_field(5, flatbuffers_, the_goo_shady, the_shade, 4, 2, the_goo)

static inline the_goo_ref_t the_goo_create(flatbuffers_builder_t *B __the_goo_formal_args)
{
    if (the_goo_start(B)
        || the_goo_hello_add(B, v0)
        || the_goo_confirmations_add(B, v1)
        || the_goo_embedded_t_add(B, v3)
        || the_goo_embedded_s_add(B, v4)
        || the_goo_shady_add(B, v5)) {
        return 0;
    }
    return the_goo_end(B);
}

static the_goo_ref_t the_goo_clone(flatbuffers_builder_t *B, the_goo_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (the_goo_start(B)
        || the_goo_hello_pick(B, t)
        || the_goo_confirmations_pick(B, t)
        || the_goo_embedded_t_pick(B, t)
        || the_goo_embedded_s_pick(B, t)
        || the_goo_shady_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, the_goo_end(B));
}

__flatbuffers_build_struct_field(0, flatbuffers_, little_whale_hop_einhorn, little_whale_c3, 4, 4, little_whale_hop)
__flatbuffers_build_struct_field(1, flatbuffers_, little_whale_hop_jupiter, little_whale_c2, 4, 4, little_whale_hop)
__flatbuffers_build_string_vector_field(2, flatbuffers_, little_whale_hop_names, little_whale_hop)
__flatbuffers_build_vector_field(3, flatbuffers_, little_whale_hop_ehlist, little_whale_c3, little_whale_c3_t, little_whale_hop)
__flatbuffers_build_table_field(4, flatbuffers_, little_whale_hop_k2, the_goo, little_whale_hop)
/* vector has keyed elements */
__flatbuffers_build_table_vector_field(5, flatbuffers_, little_whale_hop_k2vec, the_goo, little_whale_hop)
__flatbuffers_build_scalar_field(6, flatbuffers_, little_whale_hop_lunar, the_flags2, the_flags2_enum_t, 4, 4, UINT32_C(4), little_whale_hop)

static inline little_whale_hop_ref_t little_whale_hop_create(flatbuffers_builder_t *B __little_whale_hop_formal_args)
{
    if (little_whale_hop_start(B)
        || little_whale_hop_einhorn_add(B, v0)
        || little_whale_hop_jupiter_add(B, v1)
        || little_whale_hop_names_add(B, v2)
        || little_whale_hop_ehlist_add(B, v3)
        || little_whale_hop_k2_add(B, v4)
        || little_whale_hop_k2vec_add(B, v5)
        || little_whale_hop_lunar_add(B, v6)) {
        return 0;
    }
    return little_whale_hop_end(B);
}

static little_whale_hop_ref_t little_whale_hop_clone(flatbuffers_builder_t *B, little_whale_hop_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_hop_start(B)
        || little_whale_hop_einhorn_pick(B, t)
        || little_whale_hop_jupiter_pick(B, t)
        || little_whale_hop_names_pick(B, t)
        || little_whale_hop_ehlist_pick(B, t)
        || little_whale_hop_k2_pick(B, t)
        || little_whale_hop_k2vec_pick(B, t)
        || little_whale_hop_lunar_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_hop_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, little_whale_TestOrder_x0, flatbuffers_int8, int8_t, 1, 1, INT8_C(0), little_whale_TestOrder)
__flatbuffers_build_scalar_field(1, flatbuffers_, little_whale_TestOrder_x1, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(1), little_whale_TestOrder)
__flatbuffers_build_scalar_field(2, flatbuffers_, little_whale_TestOrder_x2, flatbuffers_int16, int16_t, 2, 2, INT16_C(0), little_whale_TestOrder)
__flatbuffers_build_struct_field(3, flatbuffers_, little_whale_TestOrder_x3, the_shade, 4, 2, little_whale_TestOrder)
__flatbuffers_build_string_field(4, flatbuffers_, little_whale_TestOrder_x4, little_whale_TestOrder)
__flatbuffers_build_union_field(6, flatbuffers_, little_whale_TestOrder_x5, the_u1, little_whale_TestOrder)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder_x5, the_u1, point, point)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder_x5, the_u1, foo, the_foo)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder_x5, the_u1, island, mystic_island)
__flatbuffers_build_string_vector_field(7, flatbuffers_, little_whale_TestOrder_x6, little_whale_TestOrder)
__flatbuffers_build_scalar_field(8, flatbuffers_, little_whale_TestOrder_x7, flatbuffers_double, double, 8, 8, 0.0000000000000000, little_whale_TestOrder)

static inline little_whale_TestOrder_ref_t little_whale_TestOrder_create(flatbuffers_builder_t *B __little_whale_TestOrder_formal_args)
{
    if (little_whale_TestOrder_start(B)
        || little_whale_TestOrder_x7_add(B, v8)
        || little_whale_TestOrder_x4_add(B, v4)
        || little_whale_TestOrder_x5_add_value(B, v6)
        || little_whale_TestOrder_x6_add(B, v7)
        || little_whale_TestOrder_x2_add(B, v2)
        || little_whale_TestOrder_x3_add(B, v3)
        || little_whale_TestOrder_x0_add(B, v0)
        || little_whale_TestOrder_x1_add(B, v1)
        || little_whale_TestOrder_x5_add_type(B, v6.type)) {
        return 0;
    }
    return little_whale_TestOrder_end(B);
}

static little_whale_TestOrder_ref_t little_whale_TestOrder_clone(flatbuffers_builder_t *B, little_whale_TestOrder_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_TestOrder_start(B)
        || little_whale_TestOrder_x7_pick(B, t)
        || little_whale_TestOrder_x4_pick(B, t)
        || little_whale_TestOrder_x5_pick(B, t)
        || little_whale_TestOrder_x6_pick(B, t)
        || little_whale_TestOrder_x2_pick(B, t)
        || little_whale_TestOrder_x3_pick(B, t)
        || little_whale_TestOrder_x0_pick(B, t)
        || little_whale_TestOrder_x1_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_TestOrder_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, little_whale_TestOrder2_x0, flatbuffers_int8, int8_t, 1, 1, INT8_C(0), little_whale_TestOrder2)
__flatbuffers_build_scalar_field(1, flatbuffers_, little_whale_TestOrder2_x1, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(1), little_whale_TestOrder2)
__flatbuffers_build_scalar_field(2, flatbuffers_, little_whale_TestOrder2_x1a, flatbuffers_bool, flatbuffers_bool_t, 1, 1, UINT8_C(1), little_whale_TestOrder2)
__flatbuffers_build_scalar_field(3, flatbuffers_, little_whale_TestOrder2_x2, flatbuffers_int16, int16_t, 2, 2, INT16_C(0), little_whale_TestOrder2)
__flatbuffers_build_struct_field(4, flatbuffers_, little_whale_TestOrder2_x3, the_shade, 4, 2, little_whale_TestOrder2)
__flatbuffers_build_string_field(5, flatbuffers_, little_whale_TestOrder2_x4, little_whale_TestOrder2)
__flatbuffers_build_union_field(7, flatbuffers_, little_whale_TestOrder2_x5, the_u1, little_whale_TestOrder2)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder2_x5, the_u1, point, point)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder2_x5, the_u1, foo, the_foo)
__flatbuffers_build_union_table_value_field(flatbuffers_, little_whale_TestOrder2_x5, the_u1, island, mystic_island)
__flatbuffers_build_string_vector_field(8, flatbuffers_, little_whale_TestOrder2_x6, little_whale_TestOrder2)
__flatbuffers_build_scalar_field(9, flatbuffers_, little_whale_TestOrder2_x7, flatbuffers_double, double, 8, 8, 0.0000000000000000, little_whale_TestOrder2)

static inline little_whale_TestOrder2_ref_t little_whale_TestOrder2_create(flatbuffers_builder_t *B __little_whale_TestOrder2_formal_args)
{
    if (little_whale_TestOrder2_start(B)
        || little_whale_TestOrder2_x0_add(B, v0)
        || little_whale_TestOrder2_x1_add(B, v1)
        || little_whale_TestOrder2_x1a_add(B, v2)
        || little_whale_TestOrder2_x2_add(B, v3)
        || little_whale_TestOrder2_x3_add(B, v4)
        || little_whale_TestOrder2_x4_add(B, v5)
        || little_whale_TestOrder2_x5_add(B, v7)
        || little_whale_TestOrder2_x6_add(B, v8)
        || little_whale_TestOrder2_x7_add(B, v9)) {
        return 0;
    }
    return little_whale_TestOrder2_end(B);
}

static little_whale_TestOrder2_ref_t little_whale_TestOrder2_clone(flatbuffers_builder_t *B, little_whale_TestOrder2_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_TestOrder2_start(B)
        || little_whale_TestOrder2_x0_pick(B, t)
        || little_whale_TestOrder2_x1_pick(B, t)
        || little_whale_TestOrder2_x1a_pick(B, t)
        || little_whale_TestOrder2_x2_pick(B, t)
        || little_whale_TestOrder2_x3_pick(B, t)
        || little_whale_TestOrder2_x4_pick(B, t)
        || little_whale_TestOrder2_x5_pick(B, t)
        || little_whale_TestOrder2_x6_pick(B, t)
        || little_whale_TestOrder2_x7_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_TestOrder2_end(B));
}


static inline little_whale_StoreResponse_ref_t little_whale_StoreResponse_create(flatbuffers_builder_t *B __little_whale_StoreResponse_formal_args)
{
    if (little_whale_StoreResponse_start(B)) {
        return 0;
    }
    return little_whale_StoreResponse_end(B);
}

static little_whale_StoreResponse_ref_t little_whale_StoreResponse_clone(flatbuffers_builder_t *B, little_whale_StoreResponse_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_StoreResponse_start(B)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_StoreResponse_end(B));
}


static inline little_whale_Monster_ref_t little_whale_Monster_create(flatbuffers_builder_t *B __little_whale_Monster_formal_args)
{
    if (little_whale_Monster_start(B)) {
        return 0;
    }
    return little_whale_Monster_end(B);
}

static little_whale_Monster_ref_t little_whale_Monster_clone(flatbuffers_builder_t *B, little_whale_Monster_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_Monster_start(B)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_Monster_end(B));
}

__flatbuffers_build_scalar_field(0, flatbuffers_, little_whale_MonsterId_id, flatbuffers_int32, int32_t, 4, 4, INT32_C(0), little_whale_MonsterId)

static inline little_whale_MonsterId_ref_t little_whale_MonsterId_create(flatbuffers_builder_t *B __little_whale_MonsterId_formal_args)
{
    if (little_whale_MonsterId_start(B)
        || little_whale_MonsterId_id_add(B, v0)) {
        return 0;
    }
    return little_whale_MonsterId_end(B);
}

static little_whale_MonsterId_ref_t little_whale_MonsterId_clone(flatbuffers_builder_t *B, little_whale_MonsterId_table_t t)
{
    __flatbuffers_memoize_begin(B, t);
    if (little_whale_MonsterId_start(B)
        || little_whale_MonsterId_id_pick(B, t)) {
        return 0;
    }
    __flatbuffers_memoize_end(B, t, little_whale_MonsterId_end(B));
}

#include "flatcc/flatcc_epilogue.h"
#endif /* XYZZY_BUILDER_H */

#if 0 /* FlatBuffers Schema Source */
	//buffers do not support include statements
//	include "foobar.fbs";
// in flatc, only one field can have a key, but we have no issues
// as long as the vector is sorted accordingly. The first key gets
// gets a shorter find alias method.
// (all scalar vectors can also be searched - they have find defined)
/* block comments are also allowed.
 */
//////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////
table point { x : float (key); y: float; z: float (key); }
namespace mystic;
/************ ANOTHER DOC CASE *************/
table island { lattitude : int; longitude : int; }
     /// There are two different point tables
// we test multi line doc comments here - this line should be ignored.
 /// - one in each name space.
table point { interest: agent; blank: string; geo: mystic.island; }
enum agent:int { lot, pirate, vessel, navy, parrot }
	namespace the;
//root_type point;
attribute "foo";
//attribute ""; // ensure empty strings are accepted.
/// shade is for CG applications
struct shade (force_align:2) { x: byte; y: byte; z: byte;
/// alpha is unsigned!
alpha: ubyte (key); }
/// the.ui is a union
///
/// We got one blank comment line above.
union u1 { /// Note that the.point is different from mystic.point in other namespace.
point
= /// meaningless doc comment that should be stripped
2, foo = 4, mystic.island = 17, } enum e1:short { z = -2, one , two , three = 3, }
// key on enum not supported by flatc
table foo  { m: u1; e: e1 = z (key); x : int = mystic.agent.vessel; interest: mystic.agent = pirate; strange: mystic.agent = flags2.zulu; }
// Unknown attributes can be repeated with varying types since behavior is unspecified.
enum flags : short (bit_flags, 
/// foos are plentiful - here it is an enum of value 42
foo: 42, foo, foo: "hello") { f1 = 1, f2 = 13, f3 }
enum flags2 : uint (bit_flags) { zulu, alpha, bravo, charlie, delta, echo, foxtrot }
/// A boolean enum - all enums must be type.
enum confirm : bool { no, yes }
// enums are not formally permitted in structs, but can be enabled.
// This is advanced: boolean enum binary search on struct vector ...
struct notify { primary_recipient: confirm (key); secondary_recipient: confirm; flags : flags; }
// duplicates are disallowed by default, but can be enabled
// enum dupes : byte { large = 2, great = 2, small = 0, other }
table goo { hello: string (key, required); confirmations: [confirm];
            never_mind: double = 3.1415 (deprecated);
            embedded_t: [ubyte] (nested_flatbuffer: "foo");
            embedded_s: [ubyte] (nested_flatbuffer: "little.whale.c2");
            shady: shade;
}
struct s1 (force_align:4) { index: int (key); }
struct c1 { a: ubyte; x1 : little.whale.c2; x2:uint; x3: short; light: shade (deprecated); }
/// not all constructs support doc comments - this one doesn't
namespace little.whale;
struct c2 { y : c3; }
//struct c3 { z : c1; }
struct c3 { z : the.s1; }
file_identifier "fbuz";
file_extension "cgen_test";
root_type little.whale.c2;
//root_type c2;
//root_type the.goo;
table hop { einhorn: c3 (required); jupiter: c2; names: [string] (required); ehlist: [c3]; k2: the.goo; k2vec: [the.goo]; lunar: the.flags2 = bravo; }
table TestOrder { x0 : byte; x1: bool = true; x2: short; x3: the.shade; x4: string; x5 : the.u1; x6 : [string]; x7: double; }
table TestOrder2 (original_order) { x0 : byte; x1: bool = true; x1a : bool = 1; x2: short; x3: the.shade; x4: string; x5: the.u1; x6 : [string]; x7: double; }
table StoreResponse {}
rpc_service MonsterStorage {
  Store(Monster):StoreResponse;
  Retrieve(MonsterId):Monster;
  RetrieveOne(MonsterId):Monster (deprecated);
}
/* 
*/table Monster {}
table MonsterId{ id: int; }
/* 	/ */

#endif /* FlatBuffers Schema Source */
